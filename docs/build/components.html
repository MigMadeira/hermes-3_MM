<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Components &#8212; Hermes-3 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css?v=d59dc883" />
    <script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Numerical methods" href="numerical_methods.html" />
    <link rel="prev" title="Code structure" href="code_structure.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="numerical_methods.html" title="Numerical methods"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="code_structure.html" title="Code structure"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hermes-3 0.1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Components</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="components">
<span id="sec-components"></span><h1>Components<a class="headerlink" href="#components" title="Link to this heading">¶</a></h1>
<p>This section describes the model components currently available.</p>
<section id="species-density">
<h2>Species density<a class="headerlink" href="#species-density" title="Link to this heading">¶</a></h2>
<p>The density of a species can be calculated in several different ways,
and are usually needed by other components.</p>
<section id="fixed-density">
<span id="id1"></span><h3>fixed_density<a class="headerlink" href="#fixed-density" title="Link to this heading">¶</a></h3>
<p>Set the density to a value which does not change in time. For example:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[d]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">fixed_density, ...</span>

<span class="na">AA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">2</span><span class="w"> </span><span class="c1"># Atomic mass</span>
<span class="na">charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0</span>
<span class="na">density</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1e17</span><span class="w"> </span><span class="c1"># In m^-3</span>
</pre></div>
</div>
<p>Note that the density can be a function of <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">y</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">z</span></code> coordinates
for spatial variation.</p>
<p>The implementation is in the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">FixedDensity</span></code> class:</p>
</section>
<section id="evolve-density">
<span id="id2"></span><h3>evolve_density<a class="headerlink" href="#evolve-density" title="Link to this heading">¶</a></h3>
<p>This component evolves the species density in time, using the BOUT++
time integration solver. The species charge and atomic mass must be set,
and the initial density should be specified in its own section:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[d]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">evolve_density, ...</span>

<span class="na">AA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">2</span><span class="w"> </span><span class="c1"># Atomic mass</span>
<span class="na">charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0</span>

<span class="k">[Nd]</span>
<span class="na">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1 - 0.5x</span><span class="w"> </span><span class="c1"># Initial condition, normalised to Nnorm</span>
</pre></div>
</div>
<p>The equation solved is:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial n}{\partial t} = -\nabla\cdot\left[n \left(\frac{1}{B}\mathbf{b}\times\nabla\phi + v_{||}\mathbf{b}\right)\right] + S_n\]</div>
<p>where the source <span class="math notranslate nohighlight">\(S_n\)</span> is a combination of external source, and
other processes that nay be included, including drift terms
(e.g. magnetic drift) or atomic processes (e.g. ionization).</p>
<p>Notes:</p>
<ol class="arabic simple">
<li><p>The density will be saved in the output file as <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">N</span></code> + species
label, e.g <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Nd</span></code> in the above example.</p></li>
<li><p>If <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">diagnose=true</span></code> is set in the species options then the net
source <span class="math notranslate nohighlight">\(S_n\)</span> is saved as <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">SN</span></code> + species, e.g. <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">SNd</span></code>; the
external source is saved as <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">S</span></code> + species + <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">_src</span></code> e.g. <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Sd_src</span></code>.
The time derivative of density is saved as <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ddt(N</span></code> + species + <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">)</span></code>
e.g. <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ddt(Nd)</span></code>.</p></li>
<li><p>The density source can be set in the input mesh file as a field
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">S</span></code> + species + <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">_src</span></code> e.g. <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Sd_src</span></code>. This can be overridden by
specifying the source in the input options.</p></li>
<li><p>The <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">poloidal_flows</span></code> switch controls whether the X-Y components of
the ExB flow are included (default is true). If set to <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">false</span></code> then
ExB flows are only in the X-Z plane.</p></li>
</ol>
<p>The implementation is in the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">EvolveDensity</span></code> class:</p>
</section>
<section id="upstream-density-feedback">
<span id="id3"></span><h3>upstream_density_feedback<a class="headerlink" href="#upstream-density-feedback" title="Link to this heading">¶</a></h3>
<p>This is intended for 1D simulations, where the density at <span class="math notranslate nohighlight">\(y=0\)</span> is set
by adjusting an input source. This component uses a PI controller method
to scale the density source up and down, to maintain the specified upstream
density.
The source, e.g. <code class="docutils literal notranslate"><span class="pre">Sd+_feedback</span></code>, is calculated as a product of the control signal <code class="docutils literal notranslate"><span class="pre">density_source_multiplier</span></code>,
and the array <code class="docutils literal notranslate"><span class="pre">density_source_shape</span></code> which defines the source region.
The signal is non-dimensional and the controller depends on the value of <code class="docutils literal notranslate"><span class="pre">density_source_shape</span></code> to have a good initial guess of the source.
It should be set to a reasonable value in the units of <code class="docutils literal notranslate"><span class="pre">[m-3s-1]</span></code>.
A good reasonable value is the expected steady state domain particle loss (for example due to unrecycled ions at the target).</p>
<p>For example:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[d+]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., upstream_density_feedback</span>

<span class="na">density_upstream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1e19</span><span class="w">      </span><span class="c1"># Density in m^-3</span>
<span class="na">density_controller_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1e-2</span><span class="w">  </span><span class="c1"># Feedback controller proportional (p) parameter</span>
<span class="na">density_controller_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1e-3</span><span class="w">  </span><span class="c1"># Feedback controller integral (i) parameter</span>

<span class="k">[Nd+]</span>
<span class="na">source_shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">h(pi - y) * 1e20</span><span class="w">  </span><span class="c1"># Source shape</span>
</pre></div>
</div>
<p>There are two additional settings which can make the controller more robust without excessive tuning:</p>
<p><code class="docutils literal notranslate"><span class="pre">density_source_positive</span></code> ensures the controller never takes particles away, which can prevent oscillatory
behaviour. Note that this requires some other domain particle sink to ensure control, or else the particle count can never reduce.</p>
<p><code class="docutils literal notranslate"><span class="pre">density_integral_positive</span></code> This makes sure the integral component only adds particles.
The integral component takes a long time to change value, which can result in large overshoots if the initial guess was too small.
This setting mitigates this by disabling the integral term if the density is above the desired value.</p>
<dl class="simple">
<dt>Notes:</dt><dd><ul class="simple">
<li><p>The example cases have their PI parameters tuned properly without the need of the above two settings.</p></li>
<li><p>Under certain conditions, the use of the PI controller can make the upstream density enter a very small oscillation (~0.05% of upstream value).</p></li>
<li><p>There is a separate <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">source</span></code> setting that includes a fixed (non varying) density source.</p></li>
</ul>
</dd>
</dl>
<p>The implementation is in the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">UpstreamDensityFeedback</span></code> class:</p>
</section>
<section id="fixed-fraction-ions">
<h3>fixed_fraction_ions<a class="headerlink" href="#fixed-fraction-ions" title="Link to this heading">¶</a></h3>
<p>This sets the density of a species to a fraction of the electron density.</p>
</section>
<section id="quasineutral">
<span id="id4"></span><h3>quasineutral<a class="headerlink" href="#quasineutral" title="Link to this heading">¶</a></h3>
<p>This component sets the density of one species, so that the overall
charge density is zero everywhere. This must therefore be done after
all other charged species densities have been calculated. It only
makes sense to use this component for species with a non-zero charge.</p>
</section>
</section>
<section id="species-pressure-and-temperature">
<h2>Species pressure and temperature<a class="headerlink" href="#species-pressure-and-temperature" title="Link to this heading">¶</a></h2>
<section id="isothermal">
<span id="id5"></span><h3>isothermal<a class="headerlink" href="#isothermal" title="Link to this heading">¶</a></h3>
<p>Sets the temperature of a species to a fixed value which is constant
in space and time. If the species density is set then this component
also calculates the pressure.</p>
<p>By default only saves the temperature once as a non-evolving variable.
If <code class="docutils literal notranslate"><span class="pre">diagnose</span></code> is set then pressure is also saved as a time-evolving
variable.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[e]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., isothermal</span>

<span class="na">temperature</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">10</span><span class="w">   </span><span class="c1"># Constant temperature [eV]</span>
</pre></div>
</div>
</section>
<section id="fixed-temperature">
<h3>fixed_temperature<a class="headerlink" href="#fixed-temperature" title="Link to this heading">¶</a></h3>
<p>Sets the temperature of a species to a fixed value which is constant
in time but can vary in space. If the species density is set then this
component also calculates the pressure.</p>
<p>By default only saves the temperature once as a non-evolving variable.
If <code class="docutils literal notranslate"><span class="pre">diagnose</span></code> is set then pressure is also saved as a time-evolving
variable.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[e]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., fixed_temperature</span>

<span class="na">temperature</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">10 - x</span><span class="w">   </span><span class="c1"># Spatially dependent temperature [eV]</span>
</pre></div>
</div>
</section>
<section id="evolve-pressure">
<span id="id6"></span><h3>evolve_pressure<a class="headerlink" href="#evolve-pressure" title="Link to this heading">¶</a></h3>
<p>Evolves the pressure in time. This pressure is named <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">P</span></code> where <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">&lt;species&gt;</span></code>
is the short name of the evolving species e.g. <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Pe</span></code>.</p>
<p>By default parallel thermal conduction is included, which requires a collision
time. If collisions are not calculated, then thermal conduction should be turned off
by setting <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">thermal_conduction</span> <span class="pre">=</span> <span class="pre">false</span></code> in the input options.</p>
<p>If the component option <code class="docutils literal notranslate"><span class="pre">diagnose</span> <span class="pre">=</span> <span class="pre">true</span></code> then additional fields
will be saved to the dump files: The species temperature <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">+</span> <span class="pre">name</span></code>
(e.g. <code class="docutils literal notranslate"><span class="pre">Td+</span></code> or <code class="docutils literal notranslate"><span class="pre">Te</span></code>), the time derivative <code class="docutils literal notranslate"><span class="pre">ddt(P</span> <span class="pre">+</span> <span class="pre">name)</span></code>
(e.g. <code class="docutils literal notranslate"><span class="pre">ddt(Pd+)</span></code> or <code class="docutils literal notranslate"><span class="pre">ddt(Pe)</span></code>), and the source of pressure from
other components is saved as <code class="docutils literal notranslate"><span class="pre">SP</span> <span class="pre">+</span> <span class="pre">name</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">SPd+</span></code> or <code class="docutils literal notranslate"><span class="pre">SPe</span></code>).
The pressure source is the energy density source multiplied by <code class="docutils literal notranslate"><span class="pre">2/3</span></code>
(i.e. assumes a monatomic species).</p>
<div class="math notranslate nohighlight">
\[\frac{\partial P}{\partial t} = -\nabla\cdot\left(P\mathbf{v}\right) - \frac{2}{3} P \nabla\cdot\mathbf{b}v_{||} + \frac{2}{3}\nabla\cdot\left(\kappa_{||}\mathbf{b}\mathbf{b}\cdot\nabla T\right) + \frac{2}{3}S_E + S_N\frac{1}{2}mNV^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_E\)</span> is the <code class="docutils literal notranslate"><span class="pre">energy_source</span></code> (thermal energy source),
and <span class="math notranslate nohighlight">\(S_N\)</span> is the density source.</p>
<p>Notes:</p>
<ul class="simple">
<li><p>Heat conduction through the boundary is turned off currently. This is because
heat losses are usually calculated at the sheath, so any additional heat conduction
would be in addition to the sheath heat transmission already included.</p></li>
</ul>
<p>The implementation is in <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">EvolvePressure</span></code>:</p>
</section>
<section id="evolve-energy">
<span id="id7"></span><h3>evolve_energy<a class="headerlink" href="#evolve-energy" title="Link to this heading">¶</a></h3>
<p><em>Note</em> This is currently under development and has some unresolved
issues with boundary conditions.  Only for testing purposes.</p>
<p>This evolves the sum of species internal energy and parallel kinetic
energy, <span class="math notranslate nohighlight">\(\mathcal{E}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\mathcal{E} = \frac{1}{\gamma - 1} P + \frac{1}{2}m nv_{||}^2\]</div>
<p>Note that this component requires the parallel velocity <span class="math notranslate nohighlight">\(v_{||}\)</span>
to calculate the pressure. It must therefore be listed after a component
that sets the velocity, such as <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">evolve_momentum</span></code>:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[d]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., evolve_momentum, evolve_energy</span>
</pre></div>
</div>
<p>The energy density will be saved as <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">E</span></code> (e.g <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Ed</span></code>) and the
pressure as <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">P</span></code> (e.g. <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Pd</span></code>). Additional diagnostics, such as the
temperature, can be saved by setting the option <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">diagnose</span> <span class="pre">=</span> <span class="pre">true</span></code>.</p>
</section>
<section id="snb-nonlocal-heat-flux">
<h3>SNB nonlocal heat flux<a class="headerlink" href="#snb-nonlocal-heat-flux" title="Link to this heading">¶</a></h3>
<p>Calculates the divergence of the electron heat flux using the
Shurtz-Nicolai-Busquet (SNB) model. Uses the BOUT++ implementation which is
<a class="reference external" href="https://bout-dev.readthedocs.io/en/latest/user_docs/nonlocal.html?#snb-model">documented here</a>.</p>
</section>
</section>
<section id="species-parallel-dynamics">
<h2>Species parallel dynamics<a class="headerlink" href="#species-parallel-dynamics" title="Link to this heading">¶</a></h2>
<section id="fixed-velocity">
<h3>fixed_velocity<a class="headerlink" href="#fixed-velocity" title="Link to this heading">¶</a></h3>
<p>Sets the velocity of a species to a fixed value which is constant
in time but can vary in space. If the species density is set then this
component also calculates the momentum.</p>
<p>Saves the temperature once as a non-evolving variable.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[e]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., fixed_velocity</span>

<span class="na">velocity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">10 + sin(z)</span><span class="w">   </span><span class="c1"># Spatially dependent velocity [m/s]</span>
</pre></div>
</div>
</section>
<section id="evolve-momentum">
<span id="id8"></span><h3>evolve_momentum<a class="headerlink" href="#evolve-momentum" title="Link to this heading">¶</a></h3>
<p>Evolves the momentum <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">NV</span></code> in time. The evolving quantity includes the atomic
mass number, so should be divided by <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">AA</span></code> to obtain the particle flux.</p>
<p>If the component option <code class="docutils literal notranslate"><span class="pre">diagnose</span> <span class="pre">=</span> <span class="pre">true</span></code> then additional fields
will be saved to the dump files: The velocity <code class="docutils literal notranslate"><span class="pre">V</span> <span class="pre">+</span> <span class="pre">name</span></code>
(e.g. <code class="docutils literal notranslate"><span class="pre">Vd+</span></code> or <code class="docutils literal notranslate"><span class="pre">Ve</span></code>), the time derivative <code class="docutils literal notranslate"><span class="pre">ddt(NV</span> <span class="pre">+</span> <span class="pre">name)</span></code>
(e.g. <code class="docutils literal notranslate"><span class="pre">ddt(NVd+)</span></code> or <code class="docutils literal notranslate"><span class="pre">ddt(NVe)</span></code>), and the source of momentum
density (i.e force density) from other components is saved as <code class="docutils literal notranslate"><span class="pre">SNV</span> <span class="pre">+</span>
<span class="pre">name</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">SNVd+</span></code> or <code class="docutils literal notranslate"><span class="pre">SNVe</span></code>).</p>
<p>The implementation is in <code class="docutils literal notranslate"><span class="pre">EvolveMomentum</span></code>:</p>
</section>
<section id="zero-current">
<span id="id9"></span><h3>zero_current<a class="headerlink" href="#zero-current" title="Link to this heading">¶</a></h3>
<p>This calculates the parallel flow of one charged species so that there is no net current,
using flows already calculated for other species. It is used like <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">quasineutral</span></code>:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">h+, ..., e, ...</span><span class="w">   </span><span class="c1"># Note: e after all other species</span>

<span class="k">[e]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., zero_current,...</span><span class="w"> </span><span class="c1"># Set e:velocity</span>

<span class="na">charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">-1</span><span class="w"> </span><span class="c1"># Species must have a charge</span>
</pre></div>
</div>
</section>
<section id="electron-force-balance">
<h3>electron_force_balance<a class="headerlink" href="#electron-force-balance" title="Link to this heading">¶</a></h3>
<p>This calculates a parallel electric field which balances the electron
pressure gradient and other forces on the electrons (including
collisional friction, thermal forces):</p>
<div class="math notranslate nohighlight">
\[E_{||} = \left(-\nabla p_e + F\right) / n_e\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> is the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">momentum_source</span></code> for the electrons.
This electric field is then used to calculate a force on the other species:</p>
<div class="math notranslate nohighlight">
\[F_z = Z n_z E_{||}\]</div>
<p>which is added to the ion’s <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">momentum_source</span></code>.</p>
<p>The implementation is in <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ElectronForceBalance</span></code>:</p>
</section>
</section>
<section id="electron-viscosity">
<h2>electron_viscosity<a class="headerlink" href="#electron-viscosity" title="Link to this heading">¶</a></h2>
<p>Calculates the Braginskii electron parallel viscosity, adding a force (momentum source)
to the electron momentum equation:</p>
<div class="math notranslate nohighlight">
\[F = \sqrt{B}\nabla\cdot\left[\frac{\eta_e}{B}\mathbf{b}\mathbf{b}\cdot\nabla\left(\sqrt{B}V_{||e}\right)\right]\]</div>
<p>The electron parallel viscosity is</p>
<div class="math notranslate nohighlight">
\[\eta_e = \frac{4}{3} 0.73 p_e \tau_e\]</div>
<p>where <span class="math notranslate nohighlight">\(\tau_e\)</span> is the electron collision time. The collisions between electrons
and all other species therefore need to be calculated before this component is run:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., e, ..., collisions, electron_viscosity</span>
</pre></div>
</div>
</section>
<section id="ion-viscosity">
<h2>ion_viscosity<a class="headerlink" href="#ion-viscosity" title="Link to this heading">¶</a></h2>
<p>Adds ion viscosity terms to all charged species that are not electrons.
The collision frequency is required so this is a top-level component that
must be calculated after collisions:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="s">..., collisions, ion_viscosity</span>
</pre></div>
</div>
<p>By default only the parallel diffusion of momentum is included, adding a force to each
ion’s momentum equation:</p>
<div class="math notranslate nohighlight">
\[F = \sqrt{B}\nabla\cdot\left[\frac{\eta_i}{B}\mathbf{b}\mathbf{b}\cdot\nabla\left(\sqrt{B}V_{||i}\right)\right]\]</div>
<p>The ion parallel viscosity is</p>
<div class="math notranslate nohighlight">
\[\eta_i = \frac{4}{3} 0.96 p_i \tau_i\]</div>
<p>If the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">perpendicular</span></code> option is set:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[ion_viscosity]</span>
<span class="na">perpendicular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span><span class="w"> </span><span class="c1"># Include perpendicular flows</span>
</pre></div>
</div>
<p>Then the ion scalar viscous pressure is calculated as:</p>
<div class="math notranslate nohighlight">
\[\Pi_{ci} = \Pi_{ci||} + \Pi_{ci\perp}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Pi_{ci||}\)</span> corresponds to the parallel diffusion of momentum above.</p>
<div class="math notranslate nohighlight">
\[\Pi_{ci||} = - 0.96 \frac{2p_i\tau_i}{\sqrt{B}} \partial_{||}\left(\sqrt{B} V_{||i}\right)\]</div>
<p>The perpendicular part is calculated from:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}\Pi_{ci\perp} =&amp; 0.96 p_i\tau_i \kappa \cdot \left[\mathbf{V}_E + \mathbf{V}_{di} + 1.16\frac{\mathbf{b}\times\nabla T_i}{B} \right] \\
=&amp; -0.96 p_i\tau_i\frac{1}{B}\left(\mathbf{b}\times\kappa\right)\cdot\left[\nabla\phi + \frac{\nabla p_i}{en_i} + 1.61\nabla T_i \right]\end{aligned}\end{split}\]</div>
<p>A parallel force term is added, in addition to the parallel viscosity above:</p>
<div class="math notranslate nohighlight">
\[F = -\frac{2}{3}B^{3/2}\partial_{||}\left(\frac{\Pi_{ci\perp}}{B^{3/2}}\right)\]</div>
<p>In the vorticity equation the viscosity appears as a divergence of a current:</p>
<div class="math notranslate nohighlight">
\[\mathbf{J}_{ci} = \frac{\Pi_{ci}}{2}\nabla\times\frac{\mathbf{b}}{B} - \frac{1}{3}\frac{\mathbf{b}\times\nabla\Pi_{ci}}{B}\]</div>
<p>that transfers energy between ion internal energy and <span class="math notranslate nohighlight">\(E\times B\)</span> energy:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}\frac{\partial \omega}{\partial t} =&amp; \ldots + \nabla\cdot\mathbf{J}_{ci} \\
\frac{\partial p_i}{\partial t} =&amp; \ldots - \mathbf{J}_{ci}\cdot\nabla\left(\phi + \frac{p_i}{n_0}\right)\end{aligned}\end{split}\]</div>
<p>Note that the sum of the perpendicular and parallel contributions to the ion viscosity act to damp
the net poloidal flow. This can be seen by assuming that <span class="math notranslate nohighlight">\(\phi\)</span>, <span class="math notranslate nohighlight">\(p_i\)</span> and <span class="math notranslate nohighlight">\(T_i\)</span>
are flux functions. We can then write:</p>
<div class="math notranslate nohighlight">
\[\Pi_{ci\perp} = -0.96 p_i\tau_i \frac{1}{B}\left(\mathbf{b}\times\kappa\right)\cdot\nabla\psi F\left(\psi\right)\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[F\left(\psi\right) = \frac{\partial\phi}{\partial\psi} + \frac{1}{en}\frac{\partial p_i}{\partial\psi} + 1.61\frac{\partial T_i}{\partial\psi}\]</div>
<p>Using the approximation</p>
<div class="math notranslate nohighlight">
\[\left(\mathbf{b}\times\kappa\right)\cdot\nabla\psi \simeq -RB_\zeta \partial_{||}\ln B\]</div>
<p>expanding:</p>
<div class="math notranslate nohighlight">
\[\frac{2}{\sqrt{B}}\partial_{||}\left(\sqrt{B}V_{||i}\right) = 2\partial_{||}V_{||i} + V_{||i}\partial_{||}\ln B\]</div>
<p>and neglecting parallel gradients of velocity gives:</p>
<div class="math notranslate nohighlight">
\[\Pi_{ci} \simeq 0.96 p_i\tau_i \left[ \frac{RB_{\zeta}}{B}F\left(\psi\right) - V_{||i} \right]\partial_{||}\ln B\]</div>
<p><strong>Notes</strong> and implementation details:
- The magnitude of <span class="math notranslate nohighlight">\(\Pi_{ci\perp}\)</span> and <span class="math notranslate nohighlight">\(\Pi_{ci||}\)</span> are individually</p>
<blockquote>
<div><p>limited to be less than or equal to the scalar pressure <span class="math notranslate nohighlight">\(Pi\)</span> (though can have
opposite sign). The reasoning is that if these off-diagonal terms become large then
the model is likely breaking down. Occasionally happens in low-density regions.</p>
</div></blockquote>
</section>
<section id="simple-conduction">
<h2>simple_conduction<a class="headerlink" href="#simple-conduction" title="Link to this heading">¶</a></h2>
<p>This is a simplified parallel heat conduction model that can be used when a linearised model is needed.
If used, the thermal conduction term in <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">evolve_pressure</span></code> component should be disabled.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">e, ...</span>

<span class="k">[e]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">evolve_pressure, simple_conduction</span>

<span class="na">thermal_conduction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">false</span><span class="w">  </span><span class="c1"># Disable term in evolve_pressure</span>
</pre></div>
</div>
<p>To linearise the heat conduction the temperature and density used in
calculating the Coulomb logarithm and heat conduction coefficient can
be fixed by specifying <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">conduction_temperature</span></code> and
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">conduction_density</span></code>.</p>
<p>Note: For hydrogenic plasmas this produces very similar parallel electron
heat conduction as the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">evolve_pressure</span></code> term with electron-electron collisions
disabled.</p>
</section>
<section id="drifts-and-transport">
<h2>Drifts and transport<a class="headerlink" href="#drifts-and-transport" title="Link to this heading">¶</a></h2>
<p>The ExB drift is included in the density, momentum and pressure evolution equations if
potential is calculated. Other drifts can be added with the following components.</p>
<section id="diamagnetic-drift">
<h3>diamagnetic_drift<a class="headerlink" href="#diamagnetic-drift" title="Link to this heading">¶</a></h3>
<p>Adds diamagnetic drift terms to all species’ density, pressure and parallel momentum
equations. Calculates the diamagnetic drift velocity as</p>
<div class="math notranslate nohighlight">
\[\mathbf{v}_{dia} = \frac{T}{q} \nabla\times\left(\frac{\mathbf{b}}{B}\right)\]</div>
<p>where the curvature vector <span class="math notranslate nohighlight">\(\nabla\times\left(\frac{\mathbf{b}}{B}\right)\)</span>
is read from the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">bxcv</span></code> mesh input variable.</p>
</section>
<section id="polarisation-drift">
<h3>polarisation_drift<a class="headerlink" href="#polarisation-drift" title="Link to this heading">¶</a></h3>
<p>This calculates the polarisation drift of all charged species,
including ions and electrons. It works by approximating the drift
as a potential flow:</p>
<div class="math notranslate nohighlight">
\[\mathbf{v}_{pol} = - \frac{m}{q B^2} \nabla_\perp\phi_{pol}\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_{pol}\)</span> is approximately the time derivative of the
electrostatic potential <span class="math notranslate nohighlight">\(\phi\)</span> in the frame of the fluid, with
an ion diamagnetic contribution. This is calculated by inverting a
Laplacian equation similar to that solved in the vorticity equation.</p>
<p>This component needs to be run after all other currents have been
calculated.  It marks currents as used, so out-of-order modifications
should raise errors.</p>
<p>See the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">examples/blob2d-vpol</span></code> example, which contains:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">e, vorticity, sheath_closure, polarisation_drift</span>

<span class="k">[polarisation_drift]</span>
<span class="na">diagnose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
</pre></div>
</div>
<p>Setting <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">diagnose</span> <span class="pre">=</span> <span class="pre">true</span></code> saves <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">DivJ</span></code> to the dump files with the divergence of all
currents except polarisation, and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">phi_pol</span></code> which is the polarisation flow potential.</p>
</section>
<section id="anomalous-diffusion">
<h3>anomalous_diffusion<a class="headerlink" href="#anomalous-diffusion" title="Link to this heading">¶</a></h3>
<p>Adds cross-field diffusion of particles, momentum and energy to a species.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">e, ...</span>

<span class="k">[e]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">evolve_density, evolve_momentum, evolve_pressure, anomalous_diffusion</span>

<span class="na">anomalous_D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1.0</span><span class="w">   </span><span class="c1"># Density diffusion [m^2/s]</span>
<span class="na">anomalous_chi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0,5</span><span class="w"> </span><span class="c1"># Thermal diffusion [m^2/s]</span>
<span class="na">anomalous_nu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.5</span><span class="w">  </span><span class="c1"># Kinematic viscosity [m^2/s]</span>
</pre></div>
</div>
<p>Anomalous diffusion coefficients can be functions of <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">x</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">y</span></code>.  The
coefficients can also be read from the mesh input file: If the mesh
file contains <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">D_</span></code> + the name of the species, for example <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">D_e</span></code> then
it will be read and used as the density diffusion coefficient.
Similarly, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">chi_e</span></code> is the thermal conduction coefficient, and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">nu_e</span></code>
is the kinematic viscosity. All quantities should be in SI units of
m^2/s.  Values that are set in the options (as above) override those
in the mesh file.</p>
<p>The sources of particles <span class="math notranslate nohighlight">\(S\)</span>, momentum <span class="math notranslate nohighlight">\(F\)</span> and energy
<span class="math notranslate nohighlight">\(E\)</span> are calculated from species density <span class="math notranslate nohighlight">\(N\)</span>, parallel
velocity <span class="math notranslate nohighlight">\(V\)</span> and temperature <span class="math notranslate nohighlight">\(T\)</span> using diffusion
coefficients <span class="math notranslate nohighlight">\(D\)</span>, <span class="math notranslate nohighlight">\(\chi\)</span> and <span class="math notranslate nohighlight">\(\nu\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
S =&amp; \nabla\cdot\left(D \nabla_\perp N\right) \\
F =&amp; \nabla\cdot\left(m V D \nabla_\perp N\right) + \nabla\cdot\left(m N \nu \nabla_\perp V\right)\\
E =&amp; \nabla\cdot\left(\frac{3}{2}T D \nabla_\perp N\right) + \nabla\cdot\left(N \chi \nabla_\perp T\right)
\end{aligned}\end{split}\]</div>
<p>Note that particle diffusion is treated as a density gradient-driven flow
with velocity <span class="math notranslate nohighlight">\(v_D = -D \nabla_\perp N / N\)</span>.</p>
</section>
</section>
<section id="neutral-gas-models">
<h2>Neutral gas models<a class="headerlink" href="#neutral-gas-models" title="Link to this heading">¶</a></h2>
<p>The <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">neutral_mixed</span></code> component solves fluid equations along <span class="math notranslate nohighlight">\(y\)</span>
(parallel to the magnetic field), and uses diffusive transport in <span class="math notranslate nohighlight">\(x\)</span>
and <span class="math notranslate nohighlight">\(z\)</span>.  It was adopted from the approach used in UEDGE and this paper
[Journal of Nuclear Materials, vol. 313-316, pp. 559-563 (2003)].</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}\frac{\partial n_n}{\partial t} =&amp; -\nabla\cdot\left(n_n\mathbf{b}v_{||n} + n_n\mathbf{v}_{\perp n}\right) + S\\ \frac{\partial}{\partial t}\left(n_nv_{||n}\right) =&amp; -\nabla\cdot\left(n_nv_{||n} \mathbf{b}v_{||n} + n_nv_{||n}\mathbf{v}_{\perp n}\right) - \partial_{||}p_n + \nabla_{||}\left(D_{nn}n_n\partial_{||}v_{||n}\right) + F \\ \frac{\partial p_n}{\partial t} =&amp; -\nabla\cdot\left(p_n\mathbf{b}v_{||n} + p_n\mathbf{v}_{\perp n}\right) - \frac{2}{3}p_n\nabla\cdot\left(\mathbf{b}v_{||n}\right) + \nabla\cdot\left(D_{nn}n_n\nabla_\perp T_n\right) + \frac{2}{3}Q \end{aligned}\end{split}\]</div>
<p>The parallel momentum is evolved, so that it can be exchanged with the
plasma parallel momentum, but the mass is neglected for perpendicular
motion. In the perpendicular direction, therefore, the motion is a
balance between the friction (primarily with the plasma through charge
exchange) and the pressure gradient:</p>
<div class="math notranslate nohighlight">
\[\mathbf{v}_{\perp n} = -D_{nn}\frac{1}{p_n}\nabla_\perp p_n\]</div>
<p>At the moment there is no attempt to limit these velocities, which has
been found necessary in UEDGE to get physical results in better
agreement with kinetic neutral models [Discussion, T.Rognlien].</p>
</section>
<section id="sources">
<h2>Sources<a class="headerlink" href="#sources" title="Link to this heading">¶</a></h2>
<section id="applying-sources-using-the-input-file">
<h3>Applying sources using the input file<a class="headerlink" href="#applying-sources-using-the-input-file" title="Link to this heading">¶</a></h3>
<p>The simplest way to implement a source in one of the Hermes-3 equations is through the input file.
This is done by defining an array representing values of the source across the entire domain
using the BOUT++ input file syntax (see <a class="reference external" href="https://bout-dev.readthedocs.io/en/latest/user_docs/bout_options.html">BOUT++ documentation</a>).</p>
<p>Sources are available for the density, pressure and momentum equations, and are prescribed under
a header corresponding to the chosen equation and species.</p>
<p>For example, this is how a pressure source is prescribed in the 1D-recycling example. First the domain and grid
are defined using input file functions. This creates a 400 element 1D grid with a length of 30m and an X-point at the 10m mark.
The grid increases in resolution towards the target, with a minimum grid spacing of 0.1 times the average grid spacing:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[mesh]</span>
<span class="c1"># 1D simulation, use &quot;y&quot; as the dimension along the fieldline</span>
<span class="na">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1</span>
<span class="na">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">400</span><span class="w">   </span><span class="c1"># Resolution along field-line</span>
<span class="na">nz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1</span>
<span class="na">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">30</span><span class="w">           </span><span class="c1"># Length of the domain in meters</span>
<span class="na">length_xpt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">10</span><span class="w">   </span><span class="c1"># Length from midplane to X-point [m] (i.e. this is where the source ends)</span>

<span class="na">dymin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.1</span><span class="w">  </span><span class="c1"># Minimum grid spacing near target, as fraction of average. Must be &gt; 0 and &lt; 1</span>

<span class="c1"># Parallel grid spacing — grid refinement near the divertor target (which is where the interesting</span>
<span class="c1"># stuff happens)</span>
<span class="na">dy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">(length / ny) * (1 + (1-dymin)*(1-y/pi))</span>

<span class="c1"># Calculate where the source ends in grid index (i.e. at the X-point)</span>
<span class="na">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">length_xpt / length</span>
<span class="na">y_xpt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">pi * ( 2 - dymin - sqrt( (2-dymin)^2 - 4*(1-dymin)*source ) ) / (1 - dymin)</span>
</pre></div>
</div>
<p>And here is how the calculated geometric information is used to prepare a pressure source. First, the
required total ion power flux is converted to a pressure according to <span class="math notranslate nohighlight">\(E = 3/2P\)</span>, then it is
divided by the length of the heating region to obtain the power flux required in each cell. Note
that this assumes that <span class="math notranslate nohighlight">\(dx = dz = J = 0\)</span> and that the volume upstream of the X-point is simply
an integral of <span class="math notranslate nohighlight">\(dy = mesh:length\_xpt\)</span>. If you are imposing a full B-field profile in your 1D simulation,
you will need to account for the fact that <span class="math notranslate nohighlight">\(J\)</span> is no longer constant.
In order to limit the pressure source to just the region above the X-point, it is multiplied by a Heaviside
function which returns 1 upstream of <span class="math notranslate nohighlight">\(y=mesh:y\_xpt\)</span> and 0 downstream of it.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Pd+]</span>

<span class="c1"># Initial condition for ion pressure (in terms of hermes:Nnorm * hermes:Tnorm)</span>
<span class="na">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1</span>

<span class="c1"># Input power flux to ions in W/m^2</span>
<span class="na">powerflux</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">2.5e7</span>

<span class="na">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">(powerflux*2/3 / (mesh:length_xpt))*H(mesh:y_xpt - y)</span><span class="w">  </span><span class="c1"># Input power as function of y</span>

<span class="k">[Pe]</span>

<span class="c1"># Input power flux to electrons in W/m^2</span>
<span class="na">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">`Pd+:function`</span><span class="w">  </span><span class="c1"># Same as ion pressure initially</span>

<span class="na">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">`Pd+:source`</span><span class="w">  </span><span class="c1"># Same as ion pressure source</span>
</pre></div>
</div>
</section>
<section id="applying-sources-using-the-grid-file">
<h3>Applying sources using the grid file<a class="headerlink" href="#applying-sources-using-the-grid-file" title="Link to this heading">¶</a></h3>
<p>The input file has limitations, and sometimes it is useful to prepare an arbitrary profile outside of BOUT++
and import it through the grid file. In 2D, this can be done by adding an appropriate Field3D or Field2D to the
grid netCDF file with the sources in the appropriate units.</p>
</section>
<section id="time-dependent-sources">
<h3>Time-dependent sources<a class="headerlink" href="#time-dependent-sources" title="Link to this heading">¶</a></h3>
<p>Any source can be made time-dependent by adding a flag and providing a prefactor function in the input file.
The already defined source will be multiplied by the prefactor, which is defined by a time-dependent input file function.</p>
<p>Here is the implementation in the 1D-time-dependent-sources example, where the electrons and ions are set to receive 8MW
of mean power flux each with a +/-10% sinusoidal fluctuation of a period of 50us. The density source has a mean of zero and
oscillates between <span class="math notranslate nohighlight">\(-1\times10^{22}\)</span> and <span class="math notranslate nohighlight">\(1\times10^{22}\)</span>, also with a period of 50us.</p>
<p>Note that if you have the density controller enabled, it will work to counteract the imposed density source oscillation.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Nd+]</span>
<span class="na">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">5e19 / hermes:Nnorm</span><span class="w"> </span><span class="c1"># Initial conditions</span>
<span class="na">source_time_dependent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1e22 * H(mesh:y_xpt - y)</span>
<span class="na">source_prefactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">sin((2/50)*pi*1e6*t)</span><span class="w">   </span><span class="c1">#  Oscillation between -1 and 1, period 50us</span>

<span class="k">[Pe]</span>
<span class="na">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.01</span>
<span class="na">powerflux</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">16e6</span><span class="w">  </span><span class="c1"># Input power flux in W/m^2</span>
<span class="na">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.5 * (powerflux*2/3 / (mesh:length_xpt))*H(mesh:y_xpt - y)</span><span class="w">  </span><span class="c1"># Input power as function of y</span>
<span class="na">source_time_dependent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">source_prefactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1 + 0.1 * sin((2/50)*pi*1e6*t)</span><span class="w">   </span><span class="c1">#  10% fluctuation on on  top of background source, period 50us</span>

<span class="k">[Pd+]</span>
<span class="na">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.01</span>
<span class="na">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">Pe:source</span>
<span class="na">source_time_dependent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">source_prefactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">Pe:source_prefactor</span>
</pre></div>
</div>
</section>
</section>
<section id="boundary-conditions">
<h2>Boundary conditions<a class="headerlink" href="#boundary-conditions" title="Link to this heading">¶</a></h2>
<section id="simple-boundary-conditions">
<h3>Simple boundary conditions<a class="headerlink" href="#simple-boundary-conditions" title="Link to this heading">¶</a></h3>
<section id="bout-simple-boundary-conditions">
<h4>BOUT++ simple boundary conditions<a class="headerlink" href="#bout-simple-boundary-conditions" title="Link to this heading">¶</a></h4>
<p>BOUT++ provides a number of fundamental boundary conditions including:
- dirichlet(x): boundary set to constant value of <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">x</span></code>
- neumann: boundary set to zero gradient
- free_o2: boundary set by linear extrapolation (using 2 points)
- free_o3: boundary set by quadratic extrapolation (using 3 points)</p>
<p>These can be set on different parts of the domain using the keywords
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">core</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">sol</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">pf</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">lower_target</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">upper_target</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">xin</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">xout</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">yup</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ydown</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">bndry_all</span></code>.</p>
<p>The boundary conditions can also be applied over a finite width as well as relaxed over a specified timescale.</p>
<p>These boundary conditions are implemented in BOUT++, and therefore have no access to
the normalisations within Hermes-3 and so must be used in normalised units.
Please see the <a class="reference external" href="https://bout-dev.readthedocs.io/en/latest/user_docs/boundary_options.html">BOUT++ documentation</a> for more detail,
including the full list of boundary conditions and more guidance on their use.
In case the documentation is incomplete or insufficient, please refer to the
<a class="reference external" href="https://github.com/boutproject/BOUT-dev/blob/cbd197e78f7d52721188badfd7c38a0a540a82bd/src/mesh/boundary_standard.cxx">BOUT++ boundary condition code</a>
.</p>
</section>
<section id="hermes-3-simple-boundary-conditions">
<h4>Hermes-3 simple boundary conditions<a class="headerlink" href="#hermes-3-simple-boundary-conditions" title="Link to this heading">¶</a></h4>
<p>Currently, there is only one additional simple boundary condition implemented in Hermes-3.
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">decaylength(x)</span></code> sets the boundary according to a user-set radial decay length.
This is a commonly used setting for plasma density and pressure in the tokamak SOL boundary in 2D and 3D but is not applicable in 1D.
Note that this must be provided in normalised units just like the BOUT++ simple boundary conditions.</p>
</section>
<section id="simple-boundary-condition-examples">
<h4>Simple boundary condition examples<a class="headerlink" href="#simple-boundary-condition-examples" title="Link to this heading">¶</a></h4>
<p>The below example for a 2D tokamak simulation sets the electron density to a constant value of 1e20 m:sup:<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">-3</span></code> in the core and
sets a decay length of 3mm in the SOL and PFR regions, while setting the remaining boundaries to <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">neumann</span></code>.
Example settings of the fundamental normalisation factors and the calculation of the derived ones is provided
in the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hermes</span></code> component which can be accessed by using the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hermes:</span></code> prefix in any other component in the input file.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">Nnorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1e17</span><span class="w">  </span><span class="c1"># Reference density [m^-3]</span>
<span class="na">Bnorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1</span><span class="w">   </span><span class="c1"># Reference magnetic field [T]</span>
<span class="na">Tnorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">100</span><span class="w">   </span><span class="c1"># Reference temperature [eV]</span>
<span class="na">qe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1.60218e-19</span><span class="w">   </span><span class="c1"># Electron charge</span>
<span class="na">Mp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1.67262e-27</span><span class="w">   </span><span class="c1"># Proton mass</span>
<span class="na">Cs0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">sqrt(qe * Tnorm / Mp)</span><span class="w">   </span><span class="c1"># Reference speed [m/s]</span>
<span class="na">Omega_ci</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">qe * Bnorm / Mp</span><span class="w">   </span><span class="c1"># Reference frequency [1/s]</span>
<span class="na">rho_s0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">Cs0 / Omega_ci</span><span class="w">   </span><span class="c1"># Refence length [m]</span>

<span class="k">[Ne]</span>
<span class="na">bndry_core</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">dirichlet(1e20 / hermes:Nnorm)</span>
<span class="na">bndry_sol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">decaylength(0.003 / hermes:rho_s0)</span>
<span class="na">bndry_pf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">decaylength(0.003 / hermes:rho_s0)</span>
<span class="na">bndry_all</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">neumann()</span>
</pre></div>
</div>
</section>
</section>
<section id="component-boundary-conditions">
<h3>Component boundary conditions<a class="headerlink" href="#component-boundary-conditions" title="Link to this heading">¶</a></h3>
<p>Hermes-3 includes additional boundary conditions whose complexity requires their implementation
as components. They may overwrite simple boundary conditions and must be set in the same way as other components.</p>
<section id="noflow-boundary">
<span id="id11"></span><h4>noflow_boundary<a class="headerlink" href="#noflow-boundary" title="Link to this heading">¶</a></h4>
<p>This is a species component which imposes a no-flow boundary condition
on y (parallel) boundaries.</p>
<ul class="simple">
<li><p>Zero-gradient boundary conditions are applied to <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">density</span></code>,
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">temperature</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">pressure</span></code> fields, if they are set.</p></li>
<li><p>Zero-value boundary conditions are applied to <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">velocity</span></code> and
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">momentum</span></code> if they are set.</p></li>
</ul>
<p>By default both yup and ydown boundaries are set, but can be turned
off by setting <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">noflow_lower_y</span></code> or <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">noflow_upper_y</span></code> to <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>Example: To set no-flow boundary condition on an ion <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">d+</span></code> at the lower
y boundary, with a sheath boundary at the upper y boundary:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">d+, sheath_boundary</span>

<span class="k">[d+]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">noflow_boundary</span>

<span class="na">noflow_lower_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span><span class="w">   </span><span class="c1"># This is the default</span>
<span class="na">noflow_upper_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">false</span><span class="w">  </span><span class="c1"># Turn off no-flow at upper y for d+ species</span>

<span class="k">[sheath_boundary]</span>
<span class="na">lower_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">false</span><span class="w">         </span><span class="c1"># Turn off sheath lower boundary for all species</span>
<span class="na">upper_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
</pre></div>
</div>
<p>Note that currently <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">noflow_boundary</span></code> is set per-species, whereas
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">sheath_boundary</span></code> is applied to all species. This is because sheath
boundary conditions couple all charged species together, and doesn’t
affect neutral species.</p>
<p>The implementation is in <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">NoFlowBoundary</span></code>:</p>
</section>
<section id="neutral-boundary">
<span id="id12"></span><h4>neutral_boundary<a class="headerlink" href="#neutral-boundary" title="Link to this heading">¶</a></h4>
<p>Sets Y (sheath/target) boundary conditions on neutral particle
density, temperature and pressure. A no-flow boundary condition
is set on parallel velocity and momentum. It is a species-specific
component and so goes in the list of components for the species
that the boundary condition should be applied to.</p>
<p>Just like ions can undergo fast and thermal recycling, neutrals can undergo fast or thermal
reflection at the wall. In edge codes using the kinetic neutral code EIRENE, this is typically
controlled by the <a class="reference external" href="https://www.eirene.de/old_eirene/html/surface_data.html">TRIM database</a>.
Hermes-3 features a simpler implementation for a constant, user-set fast reflection fraction <span class="math notranslate nohighlight">\(R_{f}\)</span>
and energy reflection coefficient <span class="math notranslate nohighlight">\(\alpha_{n}\)</span> based on the approach in the thesis of D.Power 2023.</p>
<p>The two types of reflection are as follows:</p>
<ul class="simple">
<li><p>Fast reflection, where a neutral atom hits the wall and reflects having lost some energy,</p></li>
<li><p>Thermal reflection, where a neutral atom hits the wall, recombines into a molecule, and then
is assumed to immediately dissociate at the Franck Condon dissociation temperature of 3eV.</p></li>
</ul>
<p>They are both implemented as a neutral energy sink calculated
from the cooling heat flux <span class="math notranslate nohighlight">\(Q_{cool}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
Q_{cool} &amp;= Q_{inc} - Q_{fast_refl} - Q_{th_refl}  \\
Q_{incident} &amp;= 2n_{n} T_{n} v_{th}^{x}  \\
Q_{fast} &amp;= 2n_{n} T_{n} v_{th}^{x} (R_{f} \alpha_{n}) \\
Q_{thermal} &amp;= T_{FC} n_{n} v_{th}^{x} (1 - R_{f}) \\
v_{th}^{x} &amp;= \frac{1}{4}\sqrt{\frac{8k_{B}T_{n}}{\pi m_{n}}}
\end{aligned}\end{split}\]</div>
<p>Where <span class="math notranslate nohighlight">\(Q_{incident}\)</span> is the neutral heat flux incident on the wall, <span class="math notranslate nohighlight">\(Q_{fast}\)</span> is the
returning heat flux from fast reflection, <span class="math notranslate nohighlight">\(Q_{thermal}\)</span> is the returning heat flux from thermal reflection
and <span class="math notranslate nohighlight">\(T_{FC}\)</span> is the Franck-Condon dissociation temperature, currently hardcoded to 3eV.
Note that the fast and incident heat flux are both of a Maxwellian distribution, and so their
formula corresponds to the 1 dimensional static Maxwellian heat flux and <span class="math notranslate nohighlight">\(v_{th}^{x}\)</span> the
corresponding 1D static Maxwellian thermal velocity (Stangeby p.69).
The thermal heat flux represents a monoenergetic distribution at <span class="math notranslate nohighlight">\(T_{n}=T_{FC}\)</span> and
is therefore calculated with a simpler formula.</p>
<p>Since different regions of the tokamak feature different incidence angles and may feature
different materials, the energy reflection coefficient and the fast reflection fraction
can be set individually for the target, PFR and SOL walls. The default values are 0.75
for <span class="math notranslate nohighlight">\(\alpha_{n}\)</span> and 0.8 for <span class="math notranslate nohighlight">\(R_{r}\)</span> and correspond to approximate values for
tungsten for incidence angles seen at the target. (Power, 2023)</p>
<p>Here are the options set to their defaults. Note that the SOL and PFR are set to have no
reflection by default so that it is compatible with a model of any dimensionality which has a target.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">d</span>

<span class="k">[d]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">... , neutral_boundary</span>

<span class="na">neutral_boundary_sol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">neutral_boundary_pfr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">neutral_boundary_upper_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">neutral_boundary_lower_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>

<span class="na">target_energy_refl_factor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.75</span>
<span class="na">sol_energy_refl_factor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.75</span>
<span class="na">pfr_energy_refl_factor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.75</span>

<span class="na">target_fast_refl_fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.80</span>
<span class="na">sol_fast_refl_fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.80</span>
<span class="na">pfr_fast_refl_fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.80</span>
</pre></div>
</div>
</section>
<section id="others">
<h4>Others<a class="headerlink" href="#others" title="Link to this heading">¶</a></h4>
<p>See <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">sheath_boundary</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">simple_sheath_boundary</span></code>.</p>
</section>
</section>
</section>
<section id="collective-quantities">
<h2>Collective quantities<a class="headerlink" href="#collective-quantities" title="Link to this heading">¶</a></h2>
<p>These components combine multiple species together. They are typically
listed after all the species groups in the component list, so that all
the species are present in the state.</p>
<p>One of the most important is the <a class="reference internal" href="#collisions">collisions</a> component. This sets collision
times for all species, which are then used</p>
<section id="sound-speed">
<span id="id13"></span><h3>sound_speed<a class="headerlink" href="#sound-speed" title="Link to this heading">¶</a></h3>
<p>Calculates the collective sound speed, by summing the pressure of all species,
and dividing by the sum of the mass density of all species:</p>
<div class="math notranslate nohighlight">
\[c_s = \sqrt{\sum_i P_i / \sum_i m_in_i}\]</div>
<p>This is set in the state as <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">sound_speed</span></code>, and is used for the numerical
diffusion terms in the parallel advection.</p>
</section>
<section id="neutral-parallel-diffusion">
<span id="id14"></span><h3>neutral_parallel_diffusion<a class="headerlink" href="#neutral-parallel-diffusion" title="Link to this heading">¶</a></h3>
<p>This adds diffusion to <strong>all</strong> neutral species (those with no or zero charge),
because it needs to be calculated after the collision frequencies are known.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">... , collisions, neutral_parallel_diffusion</span>

<span class="k">[neutral_parallel_diffusion]</span>
<span class="na">dneut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1</span><span class="w">         </span><span class="c1"># Diffusion multiplication factor</span>
<span class="na">diagnose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span><span class="w">   </span><span class="c1"># This enables diagnostic output for each species</span>
</pre></div>
</div>
<p>It is intended mainly for 1D simulations, to provide effective parallel
diffusion of particles, momentum and energy due to the projection of
cross-field diffusion:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\frac{\partial n_n}{\partial t} =&amp; \ldots + \nabla\cdot\left(\mathbf{b}D_n n_n\partial_{||}p_n\right) \\
\frac{\partial p_n}{\partial t} =&amp; \ldots + \nabla\cdot\left(\mathbf{b}D_n p_n\partial_{||}p_n\right) + \frac{2}{3}\nabla\cdot\left(\mathbf{b}\kappa_n \partial_{||}T_n\right) \\
\frac{\partial}{\partial t}\left(n_nv_{||n}\right) =&amp; \ldots + \nabla\cdot\left(\mathbf{b}D_n n_nv_{||n} \partial_{||}p_n\right) + \nabla\cdot\left(\mathbf{b}\eta_n \partial_{||}T_n\right)
\end{aligned}\end{split}\]</div>
<p>The diffusion coefficient is calculated as</p>
<div class="math notranslate nohighlight">
\[D_n = \left(\frac{B}{B_{pol}}\right)^2 \frac{T_n}{A \nu}\]</div>
<p>where <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">A</span></code> is the atomic mass number; <span class="math notranslate nohighlight">\(\nu\)</span> is the collision
frequency. The factor <span class="math notranslate nohighlight">\(B / B_{pol}\)</span> is the projection of the cross-field
direction on the parallel transport, and is the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">dneut</span></code> input setting.</p>
</section>
<section id="collisions">
<span id="id15"></span><h3>collisions<a class="headerlink" href="#collisions" title="Link to this heading">¶</a></h3>
<p>For collisions between charged particles. In the following all
quantities are in SI units except the temperatures: <span class="math notranslate nohighlight">\(T\)</span> is in
eV, so <span class="math notranslate nohighlight">\(eT\)</span> has units of Joules.</p>
<p>Debye length <span class="math notranslate nohighlight">\(\lambda_D\)</span></p>
<div class="math notranslate nohighlight">
\[\lambda_D = \sqrt{\frac{\epsilon_0 T_e}{n_e e}}\]</div>
<p>Coulomb logarithm, from [NRL formulary 2019], adapted to SI units</p>
<ul>
<li><p>For thermal electron-electron collisions</p>
<div class="math notranslate nohighlight">
\[\ln \lambda_{ee} = 30.4 - \frac{1}{2} \ln\left(n_e\right) + \frac{5}{4}\ln\left(T_e\right) - \sqrt{10^{-5} + \left(\ln T_e - 2\right)^2 / 16}\]</div>
<p>where the coefficient (30.4) differs from the NRL value due to
converting density from cgs to SI units (<span class="math notranslate nohighlight">\(30.4 = 23.5 -
0.5\ln\left(10^{-6}\right)\)</span>).</p>
</li>
<li><p>Electron-ion collisions</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ln \lambda_{ei} = \left\{\begin{array}{ll}
                         10 &amp; \textrm{if } T_e &lt; 0.1 \textrm{eV or } n_e &lt; 10^{10}m^{-3} \\
                         30 - \frac{1}{2}\ln\left(n_e\right) - \ln(Z) + \frac{3}{2}\ln\left(T_e\right) &amp; \textrm{if } T_im_e/m_i &lt; T_e &lt; 10Z^2 \\
                         31 - \frac{1}{2}\ln\left(n_e\right) + \ln\left(T_e\right) &amp; \textrm{if } T_im_e/m_i &lt; 10Z^2 &lt; T_e \\
                         23 - \frac{1}{2}\ln\left(n_i\right) + \frac{3}{2}\ln\left(T_i\right) - \ln\left(Z^2\mu\right) &amp; \textrm{if } T_e &lt; T_im_e/m_i \\
                         \end{array}\right.\end{split}\]</div>
</li>
<li><p>Mixed ion-ion collisions</p>
<div class="math notranslate nohighlight">
\[\ln \lambda_{ii'} = 29.91 - ln\left[\frac{ZZ'\left(\mu + \mu'\right)}{\mu T_{i'} + \mu'T_i}\left(\frac{n_iZ^2}{T_i} + \frac{n_{i'} Z'^2}{T_{i'}}\right)^{1/2}\right]\]</div>
<p>where like the other expressions the different constant is due to
converting from cgs to SI units: <span class="math notranslate nohighlight">\(29.91 = 23 -
0.5\ln\left(10^{-6}\right)\)</span>.</p>
</li>
</ul>
<p>The frequency of charged species <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">a</span></code> colliding with charged species <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">b</span></code> is</p>
<div class="math notranslate nohighlight">
\[\nu_{ab} = \frac{1}{3\pi^{3/2}\epsilon_0^2}\frac{Z_a^2 Z_b^2 n_b \ln\Lambda}{\left(v_a^2 + v_b^2\right)^{3/2}}\frac{\left(1 + m_a / m_b\right)}{m_a^2}\]</div>
<p>Note that the cgs expression in Hinton is divided by <span class="math notranslate nohighlight">\(\left(4\pi\epsilon_0\right)^2\)</span> to get
the expression in SI units. The thermal speeds in this expression are defined as:</p>
<div class="math notranslate nohighlight">
\[v_a^2 = 2 e T_a / m_a\]</div>
<p>Note that with this definition we recover the <a class="reference external" href="https://farside.ph.utexas.edu/teaching/plasma/lectures1/node35.html">Braginskii expressions</a>
for e-i and i-i collision times.</p>
<p>For conservation of momentum, the collision frequencies <span class="math notranslate nohighlight">\(\nu_{ab}\)</span> and <span class="math notranslate nohighlight">\(\nu_{ba}\)</span> are
related by:</p>
<div class="math notranslate nohighlight">
\[m_a n_a \nu_{ab} = m_b n_b \nu_{ba}\]</div>
<p>Momentum exchange, force on species <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">a</span></code> due to collisions with species <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">b</span></code>:</p>
<div class="math notranslate nohighlight">
\[F_{ab} = C_m \nu_{ab} m_a n_a \left( u_b - u_a \right)\]</div>
<p>Where the coefficient <span class="math notranslate nohighlight">\(C_m\)</span> for parallel flows depends on the species: For most combinations
of species this is set to 1, but for electron-ion collisions the Braginskii coefficients are used:
<span class="math notranslate nohighlight">\(C_m = 0.51\)</span> if ion charge <span class="math notranslate nohighlight">\(Z_i = 1\)</span>;  0.44 for <span class="math notranslate nohighlight">\(Z_i = 2\)</span>; 0.40 for <span class="math notranslate nohighlight">\(Z_i = 3\)</span>;
and 0.38 is used for <span class="math notranslate nohighlight">\(Z_i \ge 4\)</span>. Note that this coefficient should decline further with
increasing ion charge, tending to 0.29 as <span class="math notranslate nohighlight">\(Z_i \rightarrow \infty\)</span>.</p>
<p>Frictional heating is included by default, but can be disabled by
setting the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">frictional_heating</span></code> option to <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">false</span></code>. When enabled it
adds a source of thermal energy corresponding to the resistive heating
term:</p>
<div class="math notranslate nohighlight">
\[Q_{ab,F} = \frac{m_b}{m_a + m_b} \left( u_b - u_a \right) F_{ab}\]</div>
<p>This term has some important properties:</p>
<ol class="arabic simple">
<li><p>It is always positive: Collisions of two species with the same
temperature never leads to cooling.</p></li>
<li><p>It is Galilean invariant: Shifting both species’ velocity by the
same amount leaves <span class="math notranslate nohighlight">\(Q_{ab,F}\)</span> unchanged.</p></li>
<li><p>If both species have the same mass, the thermal energy
change due to slowing down is shared equally between them.</p></li>
<li><p>If one species is much heavier than the other, for example
electron-ion collisions, the lighter species is preferentially
heated. This recovers e.g. Braginskii expressions for <span class="math notranslate nohighlight">\(Q_{ei}\)</span>
and <span class="math notranslate nohighlight">\(Q_{ie}\)</span>.</p></li>
</ol>
<p>This can be derived by considering the exchange of energy
<span class="math notranslate nohighlight">\(W_{ab,F}\)</span> between two species at the same temperature but
different velocities. If the pressure is evolved then it contains
a term that balances the change in kinetic energy due to changes
in velocity:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\frac{\partial}{\partial t}\left(m_a n_a u_a\right) =&amp; \ldots + F_{ab} \\
\frac{\partial}{\partial t}\left(\frac{3}{2}p_a\right) =&amp; \ldots - F_{ab} u_a + W_{ab, F}
\end{aligned}\end{split}\]</div>
<p>For momentum and energy conservation we must have <span class="math notranslate nohighlight">\(F_{ab}=-F_{ba}\)</span>
and <span class="math notranslate nohighlight">\(W_{ab,F} = -W_{ba,F}\)</span>. Comparing the above to the
<a class="reference external" href="https://farside.ph.utexas.edu/teaching/plasma/lectures/node35.html">Braginskii expression</a>
we see that for ion-electron collisions the term <span class="math notranslate nohighlight">\(- F_{ab}u_a + W_{ab, F}\)</span>
goes to zero, so <span class="math notranslate nohighlight">\(W_{ab, F} \sim u_aF_{ab}\)</span> for
<span class="math notranslate nohighlight">\(m_a \gg m_b\)</span>. An expression that has all these desired properties
is</p>
<div class="math notranslate nohighlight">
\[W_{ab,F} = \left(\frac{m_a u_a + m_b u_a}{m_a + m_b}\right)F_{ab}\]</div>
<p>which is not Galilean invariant but when combined with the <span class="math notranslate nohighlight">\(- F_{ab} u_a\)</span>
term gives a change in pressure that is invariant, as required.</p>
<p>Thermal energy exchange, heat transferred to species <span class="math notranslate nohighlight">\(a\)</span> from
species <span class="math notranslate nohighlight">\(b\)</span> due to temperature differences, is given by:</p>
<div class="math notranslate nohighlight">
\[Q_{ab,T} = \nu_{ab}\frac{3n_a m_a\left(T_b - T_a\right)}{m_a + m_b}\]</div>
<ul>
<li><p>Ion-neutral and electron-neutral collisions</p>
<p>The cross-section for elastic collisions between charged and neutral
particles can vary significantly. Here for simplicity we just take
a value of <span class="math notranslate nohighlight">\(5\times 10^{-19}m^2\)</span> from the NRL formulary.</p>
</li>
<li><p>Neutral-neutral collisions</p>
<p>The cross-section is given by</p>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma = \pi \left(\frac{d_1 + d_2}{2}\right)^2\]</div>
<p>where <span class="math notranslate nohighlight">\(d_1\)</span> and <span class="math notranslate nohighlight">\(d_2\)</span> are the kinetic diameters of the two
species. Typical values are [Wikipedia] for H2 2.89e-10m, He
2.60e-10m, Ne 2.75e-10m.</p>
<p>The mean relative velocity of the two species is</p>
<div class="math notranslate nohighlight">
\[v_{rel} = \sqrt{\frac{eT_1}{m_1} + \frac{eT_2}{m_2}}\]</div>
<p>and so the collision rate of species 1 on species 2 is:</p>
<div class="math notranslate nohighlight">
\[\nu_{12} = v_{rel} n_2 \sigma\]</div>
<p>The implementation is in <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Collisions</span></code>:</p>
</section>
<section id="thermal-force">
<span id="id16"></span><h3>thermal_force<a class="headerlink" href="#thermal-force" title="Link to this heading">¶</a></h3>
<p>This implements simple expressions for the thermal force. If the
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">electron_ion</span></code> option is true (which is the default), then a momentum
source is added to all ions:</p>
<div class="math notranslate nohighlight">
\[F_z = 0.71 n_z Z^2 \nabla_{||}T_e\]</div>
<p>where <span class="math notranslate nohighlight">\(n_z\)</span> is the density of the ions of charge <span class="math notranslate nohighlight">\(Z\)</span>. There
is an equal and opposite force on the electrons.</p>
<p>If the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ion_ion</span></code> option is true (the default), then forces are
calculated between light species (atomic mass &lt; 4) and heavy species
(atomic mass &gt; 10).  If any combinations of ions are omitted, then a
warning will be printed once.
The force on the heavy ion is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
F_z =&amp; \beta \nabla_{||}T_i \\
\beta =&amp; \frac{3\left(\mu + 5\sqrt{2}Z^2\left(1.1\mu^{5/2} - 0.35\mu^{3/2}\right) - 1\right)}{2.6 - 2\mu + 5.4\mu^2} \\
\mu =&amp; m_z / \left(m_z + m_i\right)
\end{aligned}\end{split}\]</div>
<p>where subscripts <span class="math notranslate nohighlight">\(z\)</span> refer to the heavy ion, and <span class="math notranslate nohighlight">\(i\)</span>
refers to the light ion. The force on the light ion fluid is equal and
opposite: <span class="math notranslate nohighlight">\(F_i = -F_z\)</span>.</p>
<p>The implementation is in the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ThermalForce</span></code> class:</p>
</section>
<section id="recycling">
<span id="id17"></span><h3>recycling<a class="headerlink" href="#recycling" title="Link to this heading">¶</a></h3>
<p>This component calculates the flux of a species into a boundary
due to recycling of flow out of the boundary of another species.</p>
<p>The boundary fluxes might be set by sheath boundary conditions,
which potentially depend on the density and temperature of all species.
Recycling therefore can’t be calculated until all species boundary conditions
have been set. It is therefore expected that this component is a top-level
component (i.e. in the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Hermes</span></code> section) which comes after boundary conditions are set.</p>
<p>Recycling has been implemented at the target, the SOL edge and the PFR edge.
Each is off by default and must be activated with a separate flag. Each can be
assigned a separate recycle multiplier and recycle energy.</p>
<section id="configuring-thermal-recycling">
<h4>Configuring thermal recycling<a class="headerlink" href="#configuring-thermal-recycling" title="Link to this heading">¶</a></h4>
<p>A simple and commonly used way to model recycling is to assume it is fully thermal,
i.e. that every incident ion recombines into a neutral molecule and thermalises with the surface
before becoming re-emitted. Hermes-3 does not yet have a hydrogenic molecule model, and so
the molecules are assumed to instantly dissociate at the Franck-Condon dissociation temperature of 3.5eV.</p>
<p>In order to set this up, the chosen species must feature an outflow through the boundary - any cells
with an inflow have their recycling source set to zero. If a sheath boundary condition
is enabled, then this is automatically satisfied at the target through the Bohm condition.
If it is not enabled, then the target boundary must be set to <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">free_o2</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">free_o3</span></code> or <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">decaylength</span></code> to
allow an outflow.</p>
<p>The recycling component has a <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">species</span></code> option, that is a list of species
to recycle. For each of the species in that list, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">recycling</span></code> will look in
the corresponding section for the options <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">recycle_as</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">recycle_multiplier</span></code>
and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">recycle_energy</span></code> for each of the three implemented boundaries. Note that
the resulting recycling source is a simple
multiplication of the outgoing species flow and the multiplier factor.
This means that recycling <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">d+</span></code> ions into <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">d2</span></code> molecules would require a multiplier
of 0.5 to maintain a particle balance in the simulation.</p>
<p>For example, recycling <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">d+</span></code> ions into <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">d</span></code> atoms with a recycling fraction
of 0.95 at the target and 1.0 at the SOL and PFR edges.
Each returning atom has an energy of 3.5eV:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">d+, d, sheath_boundary, recycling</span>

<span class="k">[recycling]</span>
<span class="na">species</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">d+</span><span class="w">   </span><span class="c1"># Comma-separated list of species to recycle</span>

<span class="k">[d+]</span>
<span class="na">recycle_as</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">d</span><span class="w">         </span><span class="c1"># Species to recycle as</span>

<span class="na">target_recycle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">target_recycle_multiplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.95</span><span class="w"> </span><span class="c1"># Recycling fraction</span>
<span class="na">target_recycle_energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">3.5</span><span class="w">   </span><span class="c1"># Energy of recycled particles [eV]</span>

<span class="na">sol_recycle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">sol_recycle_multiplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1</span><span class="w"> </span><span class="c1"># Recycling fraction</span>
<span class="na">sol_recycle_energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">3.5</span><span class="w">   </span><span class="c1"># Energy of recycled particles [eV]</span>

<span class="na">pfr_recycle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">pfr_recycle_multiplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1</span><span class="w"> </span><span class="c1"># Recycling fraction</span>
<span class="na">pfr_recycle_energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">3.5</span><span class="w">   </span><span class="c1"># Energy of recycled particles [eV]</span>
</pre></div>
</div>
</section>
<section id="allowing-for-fast-recycling">
<h4>Allowing for fast recycling<a class="headerlink" href="#allowing-for-fast-recycling" title="Link to this heading">¶</a></h4>
<p>In reality, a fraction of incident ions will undergo specular reflection off the surface and
preserve a fraction of their energy. In the popular Monte-Carlo neutral code EIRENE, the
fast recycling fraction and the energy reflection factor are provided by the <a class="reference external" href="https://www.eirene.de/old_eirene/html/surface_data.html">TRIM database</a>
as a function of incident angle, surface material and incident particle energy.
Studies found that sheath acceleration can make the ion angle relatively consistent, e.g. 60 degrees; in (<a class="reference external" href="https://iopscience.iop.org/article/10.1088/1741-4326/abc1ce">Jae-Sun Park et al 2021 Nucl. Fusion 61 016021</a>).</p>
<p>The recycled heat flux is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\Gamma_{E_{n}} &amp;= R \times (R_{f} \alpha_{E} \Gamma_{E_{i}}^{sheath}  + (1 - R_{f}) T_{R} \Gamma_{N_{i}})) \\
\end{aligned}\end{split}\]</div>
<p>Where <span class="math notranslate nohighlight">\(R\)</span> is the recycle multiplier, <span class="math notranslate nohighlight">\(R_{f}\)</span> is the fast reflection fraction, <span class="math notranslate nohighlight">\(\alpha_{E}\)</span> is the energy reflection factor,
<span class="math notranslate nohighlight">\(\Gamma_{E_{i}}^{sheath}\)</span> is the incident heat flux from the sheath boundary condition, <span class="math notranslate nohighlight">\(T_{R}\)</span> is the recycle energy and <span class="math notranslate nohighlight">\(\Gamma_{N_{i}}\)</span> is the incident ion flux.</p>
<p><span class="math notranslate nohighlight">\(R_{f}\)</span> and <span class="math notranslate nohighlight">\(\alpha_{E}\)</span> can be set as in the below example. They can also be set to different values for the SOL and PFR by replacing
the word “target” with either “sol” or “pfr”.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[d+]</span>
<span class="na">recycle_as</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">d</span><span class="w">         </span><span class="c1"># Species to recycle as</span>

<span class="na">target_recycle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
<span class="na">target_recycle_multiplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.95</span><span class="w"> </span><span class="c1"># Recycling fraction</span>
<span class="na">target_recycle_energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">3.5</span><span class="w">   </span><span class="c1"># Energy of recycled particles [eV]</span>
<span class="na">target_fast_recycle_energy_factor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.70</span>
<span class="na">target_fast_recycle_fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.80</span>
</pre></div>
</div>
</section>
<section id="neutral-pump">
<h4>Neutral pump<a class="headerlink" href="#neutral-pump" title="Link to this heading">¶</a></h4>
<p>The recycling component also features a neutral pump which is currently implemented for
the SOL and PFR edges only, and so is not available in 1D. The pump is a region of the wall
which facilitates particle loss by incomplete recycling and neutral absorption.</p>
<p>The pump requires wall recycling to be enabled on the relevant wall region.</p>
<p>The particle loss rate <span class="math notranslate nohighlight">\(\Gamma_{N_{n}}\)</span> is the sum of the incident ions that are not recycled and the
incident neutrals which are not reflected, both of which are controlled by the pump multiplier <span class="math notranslate nohighlight">\(M_{p}\)</span>
which is set by the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">pump_multiplier</span></code> option in the input file. The unrecycled ion flux <span class="math notranslate nohighlight">\(\Gamma_{N_{i}}^{unrecycled}\)</span> is calculated using the recycling
model and allows for either thermal or fast recycling, but with the difference that the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">pump_multiplier</span></code> replaces the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">recycle_multiplier</span></code>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\Gamma_{N_{n}} &amp;= \Gamma_{N_{i}}^{unrecycled} + M_{p} \times \Gamma_{N_{n}}^{incident} \\
\Gamma_{N_{n}}^{incident} &amp;= N_{n} v_{th} = N_{n} \frac{1}{4} \sqrt{\frac{8 T_{n}}{\pi m_{n}}} \\
\end{aligned}\end{split}\]</div>
<p>Where the thermal velocity formulation is for a static maxwellian in 1D (see Stangeby p.64, eqns 2.21, 2.24)
and the temperature is in <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">eV</span></code>.</p>
<p>The heat loss rate <span class="math notranslate nohighlight">\(\Gamma_{E_{n}}\)</span> is calculated as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\Gamma_{E_{n}} &amp;= \Gamma_{E_{i}}^{unrecycled}  + M_{p} \times \Gamma_{E_{n}}^{incident} \\
\Gamma_{E_{n}}^{incident} &amp;= \gamma T_{n} N_{n} v_{th} = 2 T_{n} N_{n} \frac{1}{4} \sqrt{\frac{8 T_{n}}{\pi m_{n}}} \\
\end{aligned}\end{split}\]</div>
<p>Where the incident heat flux is for a static maxwellian in 1D (see Stangeby p.69, eqn 2.30).</p>
<dl class="simple">
<dt>The pump will be placed in any cell that</dt><dd><ol class="arabic simple">
<li><p>Is the final domain cell before the guard cells</p></li>
<li><p>Is on the SOL or PFR edge</p></li>
<li><p>Has a <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">is_pump</span></code> value of 1</p></li>
</ol>
</dd>
</dl>
<p>The field <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">is_pump</span></code> must be created by the user and added to the grid file as a <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Field2D</span></code>.</p>
</section>
<section id="diagnostic-variables">
<h4>Diagnostic variables<a class="headerlink" href="#diagnostic-variables" title="Link to this heading">¶</a></h4>
<p>Diagnostic variables for the recycled particle and energy fluxes are provided separately for the targets, the pump as well as the SOL and PFR which are grouped together as <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">wall</span></code>.
as well as the pump. In addition, the field <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">is_pump</span></code> is saved to help in plotting the pump location.</p>
</section>
</section>
<section id="binormal-stpm">
<span id="id19"></span><h3>binormal_stpm<a class="headerlink" href="#binormal-stpm" title="Link to this heading">¶</a></h3>
<p>This adds a term to <strong>all</strong> species which includes the effects of cross-field
drifts following the stellarator two point model:
<a class="reference external" href="http://dx.doi.org/10.1088/0741-3335/53/2/024009">Y. Feng et al., Plasma Phys. Control. Fusion 53 (2011) 024009</a></p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">... , binormal_stpm</span>

<span class="k">[binormal_stpm]</span>
<span class="na">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1</span><span class="w">         </span><span class="c1"># [m^2/s]  Density diffusion coefficient</span>
<span class="na">chi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">3</span><span class="w">       </span><span class="c1"># [m^2/s]  Thermal diffusion coefficient</span>
<span class="na">nu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1</span><span class="w">        </span><span class="c1"># [m^2/s]  Momentum diffusion coefficient</span>

<span class="na">Theta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">1e-3</span><span class="w">  </span><span class="c1"># Field line pitch</span>
</pre></div>
</div>
<p>It is intended only for 1D simulations, to provide effective parallel
diffusion of particles, momentum and energy due to the projection of
cross-field diffusion:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\frac{\partial N}{\partial t} =&amp; \ldots + \nabla\cdot\left(\mathbf{b}\frac{D}{\Theta}\partial_{||}N\right) \\
\frac{\partial P}{\partial t} =&amp; \ldots + \frac{2}{3}\nabla\cdot\left(\mathbf{b}\frac{\chi}{\Theta} N\partial_{||}T\right) \\
\frac{\partial}{\partial t}\left(NV\right) =&amp; \ldots + \nabla\cdot\left(\mathbf{b}\frac{\nu}{\Theta} \partial_{||}NV\right)
\end{aligned}\end{split}\]</div>
<p>The diffusion coefficients <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">chi</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">nu</span></code> and field line pitch <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Theta</span></code> are prescribed in the input file.</p>
</section>
</section>
<section id="atomic-and-molecular-reactions">
<h2>Atomic and molecular reactions<a class="headerlink" href="#atomic-and-molecular-reactions" title="Link to this heading">¶</a></h2>
<p>The formula for the reaction is used as the name of the component. This
makes writing the input file harder, since the formula must be in the exact same format
(e.g. <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">h</span> <span class="pre">+</span> <span class="pre">e</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">e</span> <span class="pre">+</span> <span class="pre">h</span></code> won’t be recognised as being the same thing),
but makes reading and understanding the file easier.</p>
<p>To include a set of reactions, it is probably easiest to group them,
and then include the group name in the components list</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., reactions</span>

<span class="k">[reactions]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">(</span>
<span class="w">        </span><span class="na">h + e -&gt; h+ + 2e,  # ionisation</span>
<span class="w">        </span><span class="na">h+ + e -&gt; h,    # Radiative + 3-body recombination</span>
<span class="w">       </span><span class="na">)</span>
</pre></div>
</div>
<p>Note that brackets can be used to split the list of reactions over multiple lines,
and trailing commas are ignored. Comments can be used if needed to add explanation.
The name of the section does not need to be <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">reactions</span></code>, and multiple components could
be created with different reaction sets. Be careful not to include the same reaction
twice.</p>
<p>When reactions are added, all the species involved must be included, or an exception
should be thrown.</p>
<section id="id20">
<h3>Diagnostic variables<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h3>
<p>Diagnostic variables are provided for each reaction channel of density, momentum and energy transfer. Additionally, charge exchange
features a diagnostic for the reaction rate (in ionisation and recombination, the reaction rate K is simply the density transfer rate S divided by the ion density).
The sign convention is always in terms of a plasma source, so that a source of plasma density, energy or momentum is positive, and a sink is negative.
Radiative energy transfer is provided separately as E is a transfer of energy between two species, while R is a net loss of energy from the system due to the plasma being transparent.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Variable prefix</p></th>
<th class="head"><p>Units</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>K</p></td>
<td><p><span class="math notranslate nohighlight">\(s^{-1}\)</span></p></td>
<td><p>Reaction rate</p></td>
</tr>
<tr class="row-odd"><td><p>S</p></td>
<td><p><span class="math notranslate nohighlight">\(m^{-3}s^{-1}\)</span></p></td>
<td><p>Density transfer rate</p></td>
</tr>
<tr class="row-even"><td><p>E</p></td>
<td><p><span class="math notranslate nohighlight">\(Wm^{-3}\)</span></p></td>
<td><p>Energy transfer rate</p></td>
</tr>
<tr class="row-odd"><td><p>R</p></td>
<td><p><span class="math notranslate nohighlight">\(Wm^{-3}\)</span></p></td>
<td><p>Radiation</p></td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic">
<li><p>Charge exchange channel diagnostics: For two species <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">a</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">b</span></code>,
the channel <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Fab_cx</span></code> is a source of momentum for species <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">a</span></code> due to
charge exchange with species <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">b</span></code>. There are corresponding sinks for
the products of the charge exchange reaction which are not saved.</p>
<p>For example,reaction <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">d</span> <span class="pre">+</span> <span class="pre">t+</span> <span class="pre">-&gt;</span> <span class="pre">d+</span> <span class="pre">+</span> <span class="pre">t</span></code> will save the following
forces (momentum sources):
- <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Fdt+_cx</span></code> is a source of momentum for deuterium atoms <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">d</span></code> and sink of momentum for deuterium ions <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">d+</span></code>.
- <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Ft+d_cx</span></code> is a source of momentum for tritium ions <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">t+</span></code> and sink of momentum for tritium atoms <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">t</span></code></p>
<p>The reason for this convention is the existence of the inverse reactions:
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">t</span> <span class="pre">+</span> <span class="pre">d+</span> <span class="pre">-&gt;</span> <span class="pre">t+</span> <span class="pre">+</span> <span class="pre">d</span></code> outputs diagnostics <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Ftd+_cx</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">Fd+t_cx</span></code>.</p>
</li>
<li><p>Reactions typically convert species from one to another, leading to
a transfer of mass momentum and energy. For a reaction converting
species <span class="math notranslate nohighlight">\(a\)</span> to species <span class="math notranslate nohighlight">\(b\)</span> at rate <span class="math notranslate nohighlight">\(R\)</span> (units
of events per second per volume) we have transfers:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\frac{\partial}{\partial t} n_a =&amp; \ldots - R \\
\frac{\partial}{\partial t} n_b =&amp; \ldots + R \\
\frac{\partial}{\partial t}\left( m n_a u_a\right) =&amp; \ldots + F_{ab} \\
\frac{\partial}{\partial t}\left( m n_a u_a\right) =&amp; \ldots + F_{ba} \\
\frac{\partial}{\partial t}\left( \frac{3}{2} p_a \right) =&amp; \ldots - F_{ab}u_a + W_{ab} - \frac{1}{2}mRu_a^2 \\
\frac{\partial}{\partial t}\left( \frac{3}{2} p_b \right) =&amp; \ldots - F_{ba}u_b + W_{ba} + \frac{1}{2}mRu_b^2
\end{aligned}\end{split}\]</div>
</li>
</ol>
<blockquote>
<div><p>where both species have the same mass: <span class="math notranslate nohighlight">\(m_a = m_b = m\)</span>. In the
pressure equations the <span class="math notranslate nohighlight">\(-F_{ab}u_a\)</span> comes from splitting the
kinetic and thermal energies; <span class="math notranslate nohighlight">\(W_{ab}=-W_{ba}\)</span> is the energy
transfer term that we need to find; The final term balances the loss
of kinetic energy at fixed momentum due to a particle source or
sink.</p>
<p>The momentum transfer <span class="math notranslate nohighlight">\(F_{ab}=-F{ba}\)</span> is the momentum carried
by the converted ions: <span class="math notranslate nohighlight">\(F_{ab}=-m R u_a\)</span>. To find
<span class="math notranslate nohighlight">\(W_{ab}\)</span> we note that for <span class="math notranslate nohighlight">\(p_a = 0\)</span> the change in pressure
must go to zero: <span class="math notranslate nohighlight">\(-F_{ab}u_a + W_{ab} -\frac{1}{2}mRu_a^2 = 0\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
W_{ab} =&amp; F_{ab}u_a + \frac{1}{2}mRu_a^2 \\
=&amp; - mR u_a^2 + \frac{1}{2}mRu_a^2\\
=&amp; -\frac{1}{2}mRu_a^2
\end{aligned}\end{split}\]</div>
<p>Substituting into the above gives:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\frac{\partial}{\partial t}\left( \frac{3}{2} p_b \right) =&amp; \ldots - F_{ba}u_b + W_{ba} + \frac{1}{2}mRu_b^2 \\
=&amp; \ldots - mRu_au_b + \frac{1}{2}mRu_a^2 + \frac{1}{2}mRu_a^2 \\
=&amp; \ldots + \frac{1}{2}mR\left(u_a - u_b\right)^2
\end{aligned}\end{split}\]</div>
<p>This has the property that the change in pressure of both species is
Galilean invariant. This transfer term is included in the Amjuel reactions
and hydrogen charge exchange.</p>
</div></blockquote>
</section>
<section id="hydrogen">
<h3>Hydrogen<a class="headerlink" href="#hydrogen" title="Link to this heading">¶</a></h3>
<p>Multiple isotopes of hydrogen can be evolved, so to keep track of this the
species labels <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">h</span></code>, <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">d</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">t</span></code> are all handled by the same hydrogen atomic
rates calculation. The following might therefore be used</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">d, t, reactions</span>

<span class="k">[reactions]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">(</span>
<span class="w">        </span><span class="na">d + e -&gt; d+ + 2e,  # Deuterium ionisation</span>
<span class="w">        </span><span class="na">t + e -&gt; t+ + 2e,  # Tritium ionisation</span>
<span class="w">       </span><span class="na">)</span>
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Reaction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>h + e -&gt; h+ + 2e</p></td>
<td><p>Hydrogen ionisation (Amjuel H.4 2.1.5)</p></td>
</tr>
<tr class="row-odd"><td><p>d + e -&gt; d+ + 2e</p></td>
<td><p>Deuterium ionisation (Amjuel H.4 2.1.5)</p></td>
</tr>
<tr class="row-even"><td><p>t + e -&gt; t+ + 2e</p></td>
<td><p>Tritium ionisation (Amjuel H.4 2.1.5)</p></td>
</tr>
<tr class="row-odd"><td><p>h + h+ -&gt; h+ + h</p></td>
<td><p>Hydrogen charge exchange (Amjuel H.3 3.1.8)</p></td>
</tr>
<tr class="row-even"><td><p>d + d+ -&gt; d+ + d</p></td>
<td><p>Deuterium charge exchange (Amjuel H.3 3.1.8)</p></td>
</tr>
<tr class="row-odd"><td><p>t + t+ -&gt; t+ + t</p></td>
<td><p>Tritium charge exchange (Amjuel H.3 3.1.8)</p></td>
</tr>
<tr class="row-even"><td><p>h + d+ -&gt; h+ + d</p></td>
<td><p>Mixed hydrogen isotope CX (Amjuel H.3 3.1.8)</p></td>
</tr>
<tr class="row-odd"><td><p>d + h+ -&gt; d+ + h</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>h + t+ -&gt; h+ + t</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>t + h+ -&gt; t+ + h</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>d + t+ -&gt; d+ + t</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>t + d+ -&gt; t+ + d</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>h+ + e -&gt; h</p></td>
<td><p>Hydrogen recombination (Amjuel H.4 2.1.8)</p></td>
</tr>
<tr class="row-odd"><td><p>d+ + e -&gt; d</p></td>
<td><p>Deuterium recombination (Amjuel H.4 2.1.8)</p></td>
</tr>
<tr class="row-even"><td><p>t+ + e -&gt; t</p></td>
<td><p>Tritium recombination (Amjuel H.4 2.1.8)</p></td>
</tr>
</tbody>
</table>
<p>In addition, the energy loss associated with the ionisation potential energy cost
as well as the photon emission during excitation and de-excitation during multi-step
ionisation is calculated using the AMJUEL rate H.10 2.1.5. The equivalent rate
for recombination is H.10 2.1.8.</p>
<p>The code to calculate the charge exchange rates is in
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hydrogen_charge_exchange.[ch]xx</span></code>. This implements reaction H.3 3.1.8 from
Amjuel (p43), scaled to different isotope masses and finite neutral
particle temperatures by using the effective temperature (Amjuel p43):</p>
<div class="math notranslate nohighlight">
\[T_{eff} = \frac{M}{M_1}T_1 + \frac{M}{M_2}T_2\]</div>
<p>The effective hydrogenic ionisation rates are calculated using Amjuel
reaction H.4 2.1.5, by D.Reiter, K.Sawada and T.Fujimoto (2016).
Effective recombination rates, which combine radiative and 3-body contributions,
are calculated using Amjuel reaction 2.1.8.</p>
</section>
<section id="helium">
<h3>Helium<a class="headerlink" href="#helium" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Reaction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>he + e -&gt; he+ + 2e</p></td>
<td><p>He ionisation, unresolved metastables (Amjuel 2.3.9a)</p></td>
</tr>
<tr class="row-odd"><td><p>he+ + e -&gt; he</p></td>
<td><p>He+ recombination, unresolved metastables (Amjuel 2.3.13a)</p></td>
</tr>
</tbody>
</table>
<p>The implementation of these rates are in the <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">AmjuelHeIonisation01</span></code>
and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">AmjuelHeRecombination10</span></code> classes:</p>
</section>
<section id="lithium">
<h3>Lithium<a class="headerlink" href="#lithium" title="Link to this heading">¶</a></h3>
<p>These rates are taken from ADAS (‘96 and ‘89)</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Reaction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>li + e -&gt; li+ + 2e</p></td>
<td><p>Lithium ionisation</p></td>
</tr>
<tr class="row-odd"><td><p>li+ + e -&gt; li+2 + 2e</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>li+2 + e -&gt; li+3 + 2e</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>li+ + e -&gt; li</p></td>
<td><p>Lithium recombination</p></td>
</tr>
<tr class="row-even"><td><p>li+2 + e -&gt; li+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>li+3 + e -&gt; li+2</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>li+ + h -&gt; li + h+</p></td>
<td><p>Charge exchange with hydrogen</p></td>
</tr>
<tr class="row-odd"><td><p>li+2 + h -&gt; li+ + h+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>li+3 + h -&gt; li+2 + h+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>li+ + d -&gt; li + d+</p></td>
<td><p>Charge exchange with deuterium</p></td>
</tr>
<tr class="row-even"><td><p>li+2 + d -&gt; li+ + d+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>li+3 + d -&gt; li+2 + d+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>li+ + t -&gt; li + t+</p></td>
<td><p>Charge exchange with tritium</p></td>
</tr>
<tr class="row-odd"><td><p>li+2 + t -&gt; li+ + t+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>li+3 + t -&gt; li+2 + t+</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>The implementation of these rates is in <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ADASLithiumIonisation</span></code>,
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ADASLithiumRecombination</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ADASLithiumCX</span></code> template classes:</p>
</section>
<section id="neon">
<h3>Neon<a class="headerlink" href="#neon" title="Link to this heading">¶</a></h3>
<p>These rates are taken from ADAS (96): SCD and PLT are used for the ionisation
rate and radiation energy loss; ACD and PRB for the recombination rate and radiation
energy loss; and CCD (89) for the charge exchange coupling to hydrogen.
The ionisation potential is also included as a source or sink of energy
for the electrons.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Reaction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ne + e -&gt; ne+ + 2e</p></td>
<td><p>Neon ionisation</p></td>
</tr>
<tr class="row-odd"><td><p>ne+ + e -&gt; ne+2 + 2e</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+2 + e -&gt; ne+3 + 2e</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+3 + e -&gt; ne+4 + 2e</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+4 + e -&gt; ne+5 + 2e</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+5 + e -&gt; ne+6 + 2e</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+6 + e -&gt; ne+7 + 2e</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+7 + e -&gt; ne+8 + 2e</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+8 + e -&gt; ne+9 + 2e</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+9 + e -&gt; ne+10 + 2e</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+ + e -&gt; ne</p></td>
<td><p>Neon recombination</p></td>
</tr>
<tr class="row-odd"><td><p>ne+2 + e -&gt; ne+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+3 + e -&gt; ne+2</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+4 + e -&gt; ne+3</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+5 + e -&gt; ne+4</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+6 + e -&gt; ne+5</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+7 + e -&gt; ne+6</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+8 + e -&gt; ne+7</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+9 + e -&gt; ne+8</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+10 + e -&gt; ne+9</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+ + h -&gt; ne + h+</p></td>
<td><p>Charge exchange with hydrogen</p></td>
</tr>
<tr class="row-odd"><td><p>ne+2 + h -&gt; ne+ + h+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+3 + h -&gt; ne+2 + h+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+4 + h -&gt; ne+3 + h+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+5 + h -&gt; ne+4 + h+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+6 + h -&gt; ne+5 + h+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+7 + h -&gt; ne+6 + h+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+8 + h -&gt; ne+7 + h+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+9 + h -&gt; ne+8 + h+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+10 + h -&gt; ne+9 + h+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+ + d -&gt; ne + d+</p></td>
<td><p>Charge exchange with deuterium</p></td>
</tr>
<tr class="row-odd"><td><p>ne+2 + d -&gt; ne+ + d+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+3 + d -&gt; ne+2 + d+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+4 + d -&gt; ne+3 + d+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+5 + d -&gt; ne+4 + d+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+6 + d -&gt; ne+5 + d+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+7 + d -&gt; ne+6 + d+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+8 + d -&gt; ne+7 + d+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+9 + d -&gt; ne+8 + d+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+10 + d -&gt; ne+9 + d+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+ + t -&gt; ne + t+</p></td>
<td><p>Charge exchange with tritium</p></td>
</tr>
<tr class="row-odd"><td><p>ne+2 + t -&gt; ne+ + t+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+3 + t -&gt; ne+2 + t+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+4 + t -&gt; ne+3 + t+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+5 + t -&gt; ne+4 + t+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+6 + t -&gt; ne+5 + t+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+7 + t -&gt; ne+6 + t+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+8 + t -&gt; ne+7 + t+</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>ne+9 + t -&gt; ne+8 + t+</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ne+10 + t -&gt; ne+9 + t+</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>The implementation of these rates is in <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ADASNeonIonisation</span></code>,
<code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ADASNeonRecombination</span></code> and <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">ADASNeonCX</span></code> template classes:</p>
</section>
<section id="fixed-fraction-radiation">
<h3>Fixed fraction radiation<a class="headerlink" href="#fixed-fraction-radiation" title="Link to this heading">¶</a></h3>
<p>These components produce volumetric electron energy losses, but don’t
otherwise modify the plasma solution: Their charge and mass density
are not calculated, and there are no interactions with other species
or boundary conditions.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fixed_fraction_hutchinson_carbon</span></code> component calculates radiation due to carbon
in coronal equilibrium, using a simple formula from <a class="reference external" href="https://doi.org/10.1088/0029-5515/34/10/I04">I.H.Hutchinson Nucl. Fusion 34 (10) 1337 - 1348 (1994)</a>:</p>
<div class="math notranslate nohighlight">
\[L\left(T_e\right) = 2\times 10^{-31} \frac{\left(T_e/10\right)^3}{1 + \left(T_e / 10\right)^{4.5}}\]</div>
<p>which has units of <span class="math notranslate nohighlight">\(Wm^3\)</span> with <span class="math notranslate nohighlight">\(T_e\)</span> in eV.</p>
<p>To use this component you can just add it to the list of components and then
configure the impurity fraction:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., fixed_fraction_hutchinson_carbon, ...</span>

<span class="k">[fixed_fraction_hutchinson_carbon]</span>
<span class="na">fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.05</span><span class="w">   </span><span class="c1"># 5% of electron density</span>
<span class="na">diagnose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span><span class="w">   </span><span class="c1"># Saves Rfixed_fraction_carbon to output</span>
</pre></div>
</div>
<p>Or to customise the name of the radiation output diagnostic a section can be
defined like this:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., c, ...</span>

<span class="k">[c]</span>
<span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">fixed_fraction_hutchinson_carbon</span>
<span class="na">fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">0.05</span><span class="w">   </span><span class="c1"># 5% of electron density</span>
<span class="na">diagnose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span><span class="w">   </span><span class="c1"># Saves Rc (R + section name)</span>
</pre></div>
</div>
<p>Carbon is also provided as an ADAS rate along with nitrogen, neon and argon. The component names are
<code class="docutils literal notranslate"><span class="pre">fixed_fraction_carbon</span></code>, <code class="docutils literal notranslate"><span class="pre">fixed_fraction_nitrogen</span></code>, <code class="docutils literal notranslate"><span class="pre">fixed_fraction_neon</span></code> and <code class="docutils literal notranslate"><span class="pre">fixed_fraction_argon</span></code>.</p>
<p>These can be used in the same way as <code class="docutils literal notranslate"><span class="pre">fixed_fraction_hutchinson_carbon</span></code>. Each rate is in the form of a 10 coefficient
log-log polynomial fit of data obtained using the open source tool <a class="reference external" href="https://github.com/cfs-energy/radas">radas</a>.
The <span class="math notranslate nohighlight">\(n {\tau}\)</span> parameter representing the density and residence time assumed in the radas
collisional-radiative model has been set to <span class="math notranslate nohighlight">\(1\times 10^{20} \times 0.5ms\)</span> based on <a class="reference external" href="https://doi.org10.1088/1361-6587/aa6b13">David Moulton et al 2017 Plasma Phys. Control. Fusion 59(6)</a>.</p>
<p>Each rate has an upper and lower bound beyond which the rate remains constant.
Please refer to the source code in <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">fixed_fraction_radiation.hxx</span></code> for the coefficients and bounds used for each rate.</p>
<p>In addition to the above rates, there are three simplified cooling curves for Argon: <code class="docutils literal notranslate"><span class="pre">fixed_fraction_argon_simplified1</span></code>,
<code class="docutils literal notranslate"><span class="pre">fixed_fraction_argon_simplified2</span></code> and <code class="docutils literal notranslate"><span class="pre">fixed_fraction_argon_simplified3</span></code>. They progressively reduce the nonlinearity in the
rate by taking out the curvature from the slopes, taking out the RHS shoulder and taking out the LHS-RHS asymmetry, respectively.
These rates may be useful in investigating the impact of the different kinds of curve nonlinearities on the solution.</p>
</section>
<section id="adjusting-reactions">
<h3>Adjusting reactions<a class="headerlink" href="#adjusting-reactions" title="Link to this heading">¶</a></h3>
<p>The reaction rates can be adjusted by a user-specified arbitrary multiplier. This can be useful for
the analysis of the impact of individual reactions. The multiplier setting must be placed under the
neutral species corresponding to the reaction, e.g. under <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">[d]</span></code> when adjusting deuterium ionisation, recombination or charge exchange.
The multiplier for the fixed fraction impurity radiation must be placed under the impurity species header, e.g. under <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">[ar]</span></code> for argon.
This functionality is not yet currently implemented for helium or neon reactions.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Setting</p></th>
<th class="head"><p>Specified under</p></th>
<th class="head"><p>Reaction</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>K_iz_multiplier</p></td>
<td><p>Neutral species</p></td>
<td><p>Ionisation rate</p></td>
</tr>
<tr class="row-odd"><td><p>R_ex_multiplier</p></td>
<td><p>Neutral species</p></td>
<td><p>Ionisation (excitation) radiation rate</p></td>
</tr>
<tr class="row-even"><td><p>K_rec_multiplier</p></td>
<td><p>Neutral species</p></td>
<td><p>Recombination rate</p></td>
</tr>
<tr class="row-odd"><td><p>R_rec_multiplier</p></td>
<td><p>Neutral species</p></td>
<td><p>Recombination radiation rate</p></td>
</tr>
<tr class="row-even"><td><p>K_cx_multiplier</p></td>
<td><p>Neutral species</p></td>
<td><p>Charge exchange rate</p></td>
</tr>
<tr class="row-odd"><td><p>R_multiplier</p></td>
<td><p>Impurity species</p></td>
<td><p>Fixed frac. impurity radiation rate</p></td>
</tr>
</tbody>
</table>
<p>The charge exchange reaction can be modified so that the momentum transfer channel is disabled. This can be useful when
testing the impact of the full neutral momentum equation equation compared to purely diffusive neutrals. Enabling
neutral momentum introduces a more accurate transport model but also significantly changes the solution as the ion momentum
is now passed onto the neutrals instead of being lost (because the diffusive model doesn’t solve for momentum).
Disabling the momentum transfer channel allows you to study the impact of the improved transport only and is set as:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[hermes]</span>
<span class="na">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">..., c, ...</span>

<span class="k">[reactions]</span>
<span class="na">no_neutral_cx_mom_gain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">true</span>
</pre></div>
</div>
</section>
</section>
<section id="electromagnetic-fields">
<h2>Electromagnetic fields<a class="headerlink" href="#electromagnetic-fields" title="Link to this heading">¶</a></h2>
<p>These are components which calculate the electric and/or magnetic
fields.</p>
<section id="vorticity">
<span id="id21"></span><h3>vorticity<a class="headerlink" href="#vorticity" title="Link to this heading">¶</a></h3>
<p>Evolves a vorticity equation, and at each call to transform() uses a matrix
inversion to calculate potential from vorticity.</p>
<p>In this component the Boussinesq approximation is made, so the
vorticity equation solved is</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot\left(\frac{\overline{A}\overline{n}}{B^2}\nabla_\perp \phi\right) \underbrace{+ \nabla\cdot\left(\sum_i\frac{A_i}{Z_i B^2}\nabla_\perp p_i\right)}_{\mathrm{if diamagnetic\_polarisation}} = \Omega\]</div>
<p>Where the sum is over species, <span class="math notranslate nohighlight">\(\overline{A}\)</span> is the average ion
atomic number, and <span class="math notranslate nohighlight">\(\overline{n}\)</span> is the normalisation density
(i.e. goes to 1 in the normalised equations). The ion diamagnetic flow
terms in this Boussinesq approximation can be written in terms of an
effective ion pressure <span class="math notranslate nohighlight">\(\hat{p}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\hat{p} \equiv \sum_i \frac{A_i}{\overline{A} Z_i} p_i\]</div>
<p>as</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot\left[\frac{\overline{A}\overline{n}}{B^2}\nabla_\perp \left(\phi + \frac{\hat{p}}{\overline{n}}\right) \right] = \Omega\]</div>
<p>Note that if <code class="docutils literal notranslate"><span class="pre">diamagnetic_polarisation</span> <span class="pre">=</span> <span class="pre">false</span></code> then the ion
pressure terms are removed from the vorticity, and also from other ion
pressure terms coming from the polarisation current
(i.e. <span class="math notranslate nohighlight">\(\hat{p}\rightarrow 0\)</span>.</p>
<p>This is a simplified version of the full vorticity definition which is:</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot\left(\sum_i \frac{A_i n_i}{B^2}\nabla_\perp \phi + \sum_i \frac{A_i}{Z_i B^2}\nabla_\perp p_i\right) = \Omega\]</div>
<p>and is derived by replacing</p>
<div class="math notranslate nohighlight">
\[\sum_i A_i n_i \rightarrow \overline{A}\overline{n}\]</div>
<p>In the case of multiple species, this Boussinesq approximation means that the ion diamagnetic flow
terms</p>
<p>The vorticity equation that is integrated in time is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}\frac{\partial \Omega}{\partial t} =&amp; \nabla\cdot\left(\mathbf{b}\sum_s Z_s n_sV_{||s}\right) \\
&amp;+ \underbrace{\nabla\cdot\left(\nabla\times\frac{\mathbf{b}}{B}\sum_s p_s\right)}_{\textrm{if diamagnetic}} + \underbrace{\nabla\cdot\mathbf{J_{exb}}}_{\mathrm{if exb\_advection}} \\
&amp;+ \nabla\cdot\left(\mathbf{b}J_{extra}\right)\end{aligned}\end{split}\]</div>
<p>The nonlinearity <span class="math notranslate nohighlight">\(\nabla\cdot\mathbf{J_{exb}}\)</span> is part of the
divergence of polarisation current. In its simplified form when
<code class="docutils literal notranslate"><span class="pre">exb_advection_simplified</span> <span class="pre">=</span> <span class="pre">true</span></code>, this is the <span class="math notranslate nohighlight">\(E\times B\)</span>
advection of vorticity:</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot\mathbf{J_{exb}} = -\nabla\cdot\left(\Omega \mathbf{V}_{E\times B}\right)\]</div>
<p>When <code class="docutils literal notranslate"><span class="pre">exb_advection_simplified</span> <span class="pre">=</span> <span class="pre">false</span></code> then the more complete
(Boussinesq approximation) form is used:</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot\mathbf{J_{exb}} = -\nabla\cdot\left[\frac{\overline{A}}{2B^2}\nabla_\perp\left(\mathbf{V}_{E\times B}\cdot\nabla \hat{p}\right) + \frac{\Omega}{2} \mathbf{V}_{E\times B} + \frac{\overline{A}\overline{n}}{2B^2}\nabla_\perp^2\phi\left(\mathbf{V}_{E\times B} + \frac{\mathbf{b}}{B}\times\nabla\hat{p}\right) \right]\]</div>
<p>The form of the vorticity equation is based on <a class="reference external" href="https://doi.org/10.1063/1.1623492">Simakov &amp; Catto</a> (corrected in <a class="reference external" href="https://doi.org/10.1063/1.1703527">erratum 2004</a>), in the Boussinesq limit and
with the first term modified to conserve energy. In the limit of zero
ion pressure and constant <span class="math notranslate nohighlight">\(B\)</span> it reduces to the simplified form.</p>
</section>
<section id="relax-potential">
<h3>relax_potential<a class="headerlink" href="#relax-potential" title="Link to this heading">¶</a></h3>
<p>This component evolves a vorticity equation, similar to the <code class="docutils literal notranslate"><span class="pre">vorticity</span></code> component.
Rather than inverting an elliptic equation at every timestep, this component evolves
the potential in time as a diffusion equation.</p>
</section>
<section id="electromagnetic">
<h3>electromagnetic<a class="headerlink" href="#electromagnetic" title="Link to this heading">¶</a></h3>
<p>This component modifies the definition of momentum of all species, to
include the contribution from the electromagnetic potential
<span class="math notranslate nohighlight">\(A_{||}\)</span>.</p>
<p>Assumes that “momentum” <span class="math notranslate nohighlight">\(p_s\)</span> calculated for all species
<span class="math notranslate nohighlight">\(s\)</span> is</p>
<div class="math notranslate nohighlight">
\[p_s = m_s n_s v_{||s} + Z_s e n_s A_{||}\]</div>
<p>which arises once the electromagnetic contribution to the force on
each species is included in the momentum equation. This is normalised
so that in dimensionless quantities</p>
<div class="math notranslate nohighlight">
\[p_s = A n v_{||} + Z n A_{||}\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(Z\)</span> are the atomic number and charge of the
species.</p>
<p>The current density <span class="math notranslate nohighlight">\(j_{||}\)</span> in SI units is</p>
<div class="math notranslate nohighlight">
\[j_{||} = -\frac{1}{\mu_0}\nabla_\perp^2 A_{||}\]</div>
<p>which when normalised in Bohm units becomes</p>
<div class="math notranslate nohighlight">
\[j_{||} = - \frac{1}{\beta_{em}}\nabla_\perp^2 A_{||}\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta_{em}\)</span> is a normalisation parameter which is half
the plasma electron beta as normally defined:</p>
<div class="math notranslate nohighlight">
\[\beta_{em} = \frac{\mu_0 e \overline{n} \overline{T}}{\overline{B}^2}\]</div>
<p>To convert the species momenta into a current, we take the sum of
<span class="math notranslate nohighlight">\(p_s Z_s e / m_s\)</span>. In terms of normalised quantities this gives:</p>
<div class="math notranslate nohighlight">
\[- \frac{1}{\beta_{em}} \nabla_\perp^2 A_{||} + \sum_s \frac{Z^2 n_s}{A}A_{||} = \sum_s \frac{Z}{A} p_s\]</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Components</a><ul>
<li><a class="reference internal" href="#species-density">Species density</a><ul>
<li><a class="reference internal" href="#fixed-density">fixed_density</a></li>
<li><a class="reference internal" href="#evolve-density">evolve_density</a></li>
<li><a class="reference internal" href="#upstream-density-feedback">upstream_density_feedback</a></li>
<li><a class="reference internal" href="#fixed-fraction-ions">fixed_fraction_ions</a></li>
<li><a class="reference internal" href="#quasineutral">quasineutral</a></li>
</ul>
</li>
<li><a class="reference internal" href="#species-pressure-and-temperature">Species pressure and temperature</a><ul>
<li><a class="reference internal" href="#isothermal">isothermal</a></li>
<li><a class="reference internal" href="#fixed-temperature">fixed_temperature</a></li>
<li><a class="reference internal" href="#evolve-pressure">evolve_pressure</a></li>
<li><a class="reference internal" href="#evolve-energy">evolve_energy</a></li>
<li><a class="reference internal" href="#snb-nonlocal-heat-flux">SNB nonlocal heat flux</a></li>
</ul>
</li>
<li><a class="reference internal" href="#species-parallel-dynamics">Species parallel dynamics</a><ul>
<li><a class="reference internal" href="#fixed-velocity">fixed_velocity</a></li>
<li><a class="reference internal" href="#evolve-momentum">evolve_momentum</a></li>
<li><a class="reference internal" href="#zero-current">zero_current</a></li>
<li><a class="reference internal" href="#electron-force-balance">electron_force_balance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#electron-viscosity">electron_viscosity</a></li>
<li><a class="reference internal" href="#ion-viscosity">ion_viscosity</a></li>
<li><a class="reference internal" href="#simple-conduction">simple_conduction</a></li>
<li><a class="reference internal" href="#drifts-and-transport">Drifts and transport</a><ul>
<li><a class="reference internal" href="#diamagnetic-drift">diamagnetic_drift</a></li>
<li><a class="reference internal" href="#polarisation-drift">polarisation_drift</a></li>
<li><a class="reference internal" href="#anomalous-diffusion">anomalous_diffusion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#neutral-gas-models">Neutral gas models</a></li>
<li><a class="reference internal" href="#sources">Sources</a><ul>
<li><a class="reference internal" href="#applying-sources-using-the-input-file">Applying sources using the input file</a></li>
<li><a class="reference internal" href="#applying-sources-using-the-grid-file">Applying sources using the grid file</a></li>
<li><a class="reference internal" href="#time-dependent-sources">Time-dependent sources</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boundary-conditions">Boundary conditions</a><ul>
<li><a class="reference internal" href="#simple-boundary-conditions">Simple boundary conditions</a><ul>
<li><a class="reference internal" href="#bout-simple-boundary-conditions">BOUT++ simple boundary conditions</a></li>
<li><a class="reference internal" href="#hermes-3-simple-boundary-conditions">Hermes-3 simple boundary conditions</a></li>
<li><a class="reference internal" href="#simple-boundary-condition-examples">Simple boundary condition examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#component-boundary-conditions">Component boundary conditions</a><ul>
<li><a class="reference internal" href="#noflow-boundary">noflow_boundary</a></li>
<li><a class="reference internal" href="#neutral-boundary">neutral_boundary</a></li>
<li><a class="reference internal" href="#others">Others</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#collective-quantities">Collective quantities</a><ul>
<li><a class="reference internal" href="#sound-speed">sound_speed</a></li>
<li><a class="reference internal" href="#neutral-parallel-diffusion">neutral_parallel_diffusion</a></li>
<li><a class="reference internal" href="#collisions">collisions</a></li>
<li><a class="reference internal" href="#thermal-force">thermal_force</a></li>
<li><a class="reference internal" href="#recycling">recycling</a><ul>
<li><a class="reference internal" href="#configuring-thermal-recycling">Configuring thermal recycling</a></li>
<li><a class="reference internal" href="#allowing-for-fast-recycling">Allowing for fast recycling</a></li>
<li><a class="reference internal" href="#neutral-pump">Neutral pump</a></li>
<li><a class="reference internal" href="#diagnostic-variables">Diagnostic variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#binormal-stpm">binormal_stpm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#atomic-and-molecular-reactions">Atomic and molecular reactions</a><ul>
<li><a class="reference internal" href="#id20">Diagnostic variables</a></li>
<li><a class="reference internal" href="#hydrogen">Hydrogen</a></li>
<li><a class="reference internal" href="#helium">Helium</a></li>
<li><a class="reference internal" href="#lithium">Lithium</a></li>
<li><a class="reference internal" href="#neon">Neon</a></li>
<li><a class="reference internal" href="#fixed-fraction-radiation">Fixed fraction radiation</a></li>
<li><a class="reference internal" href="#adjusting-reactions">Adjusting reactions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#electromagnetic-fields">Electromagnetic fields</a><ul>
<li><a class="reference internal" href="#vorticity">vorticity</a></li>
<li><a class="reference internal" href="#relax-potential">relax_potential</a></li>
<li><a class="reference internal" href="#electromagnetic">electromagnetic</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="code_structure.html"
                          title="previous chapter">Code structure</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="numerical_methods.html"
                          title="next chapter">Numerical methods</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/components.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="numerical_methods.html" title="Numerical methods"
             >next</a> |</li>
        <li class="right" >
          <a href="code_structure.html" title="Code structure"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Hermes-3 0.1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Components</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2020, B. Dudson.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.5.
    </div>
  </body>
</html>